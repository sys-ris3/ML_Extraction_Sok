From ea9df4aa6cecbd4a956d49512bf2fc42429b87ce Mon Sep 17 00:00:00 2001
From: Zhichuang Sun <sun.zhi@husky.neu.edu>
Date: Fri, 14 Aug 2020 02:55:58 +0000
Subject: [PATCH 09/12] tflite ca: add darknet support

Signed-off-by: Zhichuang Sun <sun.zhi@husky.neu.edu>
---
 third_party/optee_delegate/darknet_ca.BUILD        |  68 ++
 .../optee_delegate/darknet_ca/include/darknet.h    | 183 +++++
 .../darknet_ca/include/tee_client_api.h            | 550 +++++++++++++
 .../darknet_ca/src/activation_layer.c              |  33 +
 .../darknet_ca/src/activation_layer.h              |  13 +
 .../optee_delegate/darknet_ca/src/activations.c    |  51 ++
 .../optee_delegate/darknet_ca/src/activations.h    |  18 +
 .../optee_delegate/darknet_ca/src/add_mask_layer.c |  47 ++
 .../optee_delegate/darknet_ca/src/add_mask_layer.h |  12 +
 .../optee_delegate/darknet_ca/src/avgpool_layer.c  |  54 ++
 .../optee_delegate/darknet_ca/src/avgpool_layer.h  |  14 +
 .../darknet_ca/src/batchnorm_layer.c               |  99 +++
 .../darknet_ca/src/batchnorm_layer.h               |  10 +
 third_party/optee_delegate/darknet_ca/src/blas.c   | 111 +++
 third_party/optee_delegate/darknet_ca/src/blas.h   |  18 +
 .../optee_delegate/darknet_ca/src/ca_cmds.c        | 186 +++++
 .../optee_delegate/darknet_ca/src/ca_cmds.h        |  18 +
 .../optee_delegate/darknet_ca/src/dropout_layer.c  |  18 +
 .../optee_delegate/darknet_ca/src/dropout_layer.h  |  13 +
 third_party/optee_delegate/darknet_ca/src/layer.c  |  20 +
 third_party/optee_delegate/darknet_ca/src/layer.h  |   1 +
 .../darknet_ca/src/linear_transform_layer.c        |  65 ++
 .../darknet_ca/src/linear_transform_layer.h        |  12 +
 third_party/optee_delegate/darknet_ca/src/list.c   |  78 ++
 third_party/optee_delegate/darknet_ca/src/list.h   |  13 +
 .../optee_delegate/darknet_ca/src/network.c        | 190 +++++
 .../optee_delegate/darknet_ca/src/network.h        |  14 +
 .../optee_delegate/darknet_ca/src/option_list.c    | 123 +++
 .../optee_delegate/darknet_ca/src/option_list.h    |  19 +
 third_party/optee_delegate/darknet_ca/src/parser.c | 681 ++++++++++++++++
 third_party/optee_delegate/darknet_ca/src/parser.h |  11 +
 .../darknet_ca/src/shuffle_channel_layer.c         |  60 ++
 .../darknet_ca/src/shuffle_channel_layer.h         |  12 +
 .../optee_delegate/darknet_ca/src/softmax_layer.c  |  30 +
 .../optee_delegate/darknet_ca/src/softmax_layer.h  |  19 +
 third_party/optee_delegate/darknet_ca/src/tags     | 215 +++++
 third_party/optee_delegate/darknet_ca/src/utils.c  | 476 +++++++++++
 third_party/optee_delegate/darknet_ca/src/utils.h  |  96 +++
 third_party/optee_delegate/darknet_ca/tags         | 908 +++++++++++++++++++++
 39 files changed, 4559 insertions(+)
 create mode 100644 third_party/optee_delegate/darknet_ca.BUILD
 create mode 100644 third_party/optee_delegate/darknet_ca/include/darknet.h
 create mode 100644 third_party/optee_delegate/darknet_ca/include/tee_client_api.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/activation_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/activation_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/activations.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/activations.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/add_mask_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/add_mask_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/avgpool_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/avgpool_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/batchnorm_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/batchnorm_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/blas.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/blas.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/ca_cmds.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/ca_cmds.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/dropout_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/dropout_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/linear_transform_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/linear_transform_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/list.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/list.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/network.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/network.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/option_list.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/option_list.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/parser.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/parser.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/softmax_layer.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/softmax_layer.h
 create mode 100644 third_party/optee_delegate/darknet_ca/src/tags
 create mode 100644 third_party/optee_delegate/darknet_ca/src/utils.c
 create mode 100644 third_party/optee_delegate/darknet_ca/src/utils.h
 create mode 100644 third_party/optee_delegate/darknet_ca/tags

diff --git a/third_party/optee_delegate/darknet_ca.BUILD b/third_party/optee_delegate/darknet_ca.BUILD
new file mode 100644
index 0000000..b2c4055
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca.BUILD
@@ -0,0 +1,68 @@
+cc_library(
+    name = "libdarknetes",
+    srcs = [
+		"src/utils.c",
+		"src/list.c",
+		"src/activations.c",
+		"src/blas.c",
+		"src/dropout_layer.c",
+		"src/softmax_layer.c",
+		"src/network.c",
+		"src/parser.c",
+		"src/option_list.c",
+		"src/avgpool_layer.c",
+		"src/layer.c",
+		"src/activation_layer.c",
+		"src/batchnorm_layer.c",
+		"src/add_mask_layer.c",
+		"src/linear_transform_layer.c",
+		"src/shuffle_channel_layer.c",
+		"src/ca_cmds.c",
+    ],
+    hdrs = [
+        "include/darknet.h",
+        "include/tee_client_api.h",
+		"src/utils.h",
+		"src/ca_cmds.h",
+		"src/list.h",
+		"src/activations.h",
+		"src/blas.h",
+		"src/dropout_layer.h",
+		"src/softmax_layer.h",
+		"src/network.h",
+		"src/parser.h",
+		"src/option_list.h",
+		"src/avgpool_layer.h",
+		"src/layer.h",
+		"src/activation_layer.h",
+		"src/batchnorm_layer.h",
+		"src/add_mask_layer.h",
+		"src/linear_transform_layer.h",
+		"src/shuffle_channel_layer.h",
+    ],
+    copts = [
+        "-DDEBUG",
+        "-fPIC",
+        "-c",
+        "-Wall",
+        "-Wno-unused-result",
+        "-Wno-unknown-pragmas",
+        "-Wfatal-errors",
+    ],
+    includes = [
+        "include",
+        "src",
+    ],
+    linkopts = select({
+        "@org_tensorflow//tensorflow:android": [
+            "-lm",
+        ],
+        "//conditions:default": [
+            "-lm",
+        ],
+    }),
+    deps = [
+            "@optee_client//:libteec",
+            ],
+    visibility = ["//visibility:public"],
+)
diff --git a/third_party/optee_delegate/darknet_ca/include/darknet.h b/third_party/optee_delegate/darknet_ca/include/darknet.h
new file mode 100644
index 0000000..ed90aaf
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/include/darknet.h
@@ -0,0 +1,183 @@
+#ifndef DARKNET_API
+#define DARKNET_API
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SECRET_NUM -1234
+
+typedef enum{
+    RELU, NOACT, RELU6
+} ACTIVATION;
+
+typedef enum {
+    SOFTMAX,
+    DROPOUT,
+    AVGPOOL,
+    ACTIVE,
+    BATCHNORM,
+    NETWORK,
+    ADD_MASK,
+    LINEAR_TRANSFORM,
+    SHUFFLE_CHANNEL,
+    BLANK
+} LAYER_TYPE;
+
+struct network;
+typedef struct network network;
+
+struct layer;
+typedef struct layer layer;
+
+struct layer{
+    LAYER_TYPE type;
+    ACTIVATION activation;
+    void (*forward)   (struct layer, struct network);
+    int batch_normalize;
+    int batch;
+    int inputs;
+    int outputs;
+    int nweights;
+    int nbiases;
+    int extra;
+    int h,w,c;
+    int out_h, out_w, out_c;
+    int n;
+    int groups;
+    int size;
+    int stride;
+    int flatten;
+    int spatial;
+    int pad;
+    int sqrt;
+    int index;
+    int binary;
+    int noloss;
+    int softmax;
+    int total;
+
+
+    float temperature;
+    float probability;
+    float scale;
+
+    /* custom op layer weights*/
+    /* add_mask */
+    float *rscalar;
+    /* linear_transform & shuffle_channel */
+    float *rbias;
+    int *obfweights;
+    int units;
+    /* NHWC(tflite) to NCHW(darknet) */
+    int nhwc;
+    /* batchnorm layer has bias weights */
+    int bn_bias;
+
+    float * biases;
+    float * scales;
+    float * weights;
+    float * output;
+
+    float * rolling_mean;
+    float * rolling_variance;
+};
+
+void free_layer(layer);
+
+typedef struct network{
+    int ta_netid;
+
+    int n;
+    int batch;
+    size_t *seen;
+    int *t;
+    layer *layers;
+    float *output;
+
+    int inputs;
+    int outputs;
+    int h, w, c;
+
+    float *input;
+    int index;
+
+} network;
+
+
+network *load_network(char *cfg, char *weights, int clear);
+
+typedef struct node{
+    void *val;
+    struct node *next;
+    struct node *prev;
+} node;
+
+typedef struct list{
+    int size;
+    node *front;
+    node *back;
+} list;
+
+list *read_data_cfg(char *filename);
+list *read_cfg(char *filename);
+unsigned char *read_file(char *filename);
+
+void forward_network(network *net);
+void set_batch_network(network *net, int b);
+
+
+void copy_cpu(int N, float *X, int INCX, float *Y, int INCY);
+void scal_cpu(int N, float ALPHA, float *X, int INCX);
+void fill_cpu(int N, float ALPHA, float * X, int INCX);
+void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial);
+void normalize_cpu_nhwc(float *x, float *mean, float *variance, int batch, int filters, int spatial);
+void softmax(float *input, int n, float temp, int stride, float *output);
+
+char *option_find_str(list *l, char *key, char *def);
+int option_find_int(list *l, char *key, int def);
+int option_find_int_quiet(list *l, char *key, int def);
+
+network *parse_network_cfg(char *filename);
+void save_weights(network *net, char *filename);
+void load_weights(network *net, char *filename);
+void save_weights_upto(network *net, char *filename, int cutoff);
+void load_weights_upto(network *net, char *filename, int start, int cutoff);
+
+layer get_network_output_layer(network *net);
+float *network_predict(network *net, float *input);
+
+int network_width(network *net);
+int network_height(network *net);
+
+void find_replace(char *str, char *orig, char *rep, char *output);
+void free_ptrs(void **ptrs, int n);
+char *fgetl(FILE *fp);
+void strip(char *s);
+float sec(clock_t clocks);
+void **list_to_array(list *l);
+void top_k(float *a, int n, int k, int *index);
+int *read_map(char *filename);
+void error(const char *s);
+int max_index(float *a, int n);
+int max_int_index(int *a, int n);
+int sample_array(float *a, int n);
+void free_list(list *l);
+float mse_array(float *a, int n);
+float variance_array(float *a, int n);
+float mag_array(float *a, int n);
+void scale_array(float *a, int n, float s);
+float mean_array(float *a, int n);
+float sum_array(float *a, int n);
+void normalize_array(float *a, int n);
+int *read_intlist(char *s, int *n, int d);
+
+network *load_network_ca(char *cfg, char *weights, int clear); 
+float *network_predict_ca(network *net, float *input); 
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/include/tee_client_api.h b/third_party/optee_delegate/darknet_ca/include/tee_client_api.h
new file mode 100644
index 0000000..70e76ae
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/include/tee_client_api.h
@@ -0,0 +1,550 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics International N.V.
+ * All rights reserved.
+ * Copyright (c) 2015, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef TEE_CLIENT_API_H
+#define TEE_CLIENT_API_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <limits.h>
+
+/*
+ * Defines the number of available memory references in an open session or
+ * invoke command operation payload.
+ */
+#define TEEC_CONFIG_PAYLOAD_REF_COUNT 4
+
+/**
+ * Defines the maximum size of a single shared memory block, in bytes, of both
+ * API allocated and API registered memory. There is no good value to put here
+ * (limits depend on specific config used), so this define does not provide any
+ * restriction in this implementation.
+ */
+#define TEEC_CONFIG_SHAREDMEM_MAX_SIZE ULONG_MAX
+
+/**
+ * Flag constants indicating the type of parameters encoded inside the
+ * operation payload (TEEC_Operation), Type is uint32_t.
+ *
+ * TEEC_NONE                   The Parameter is not used
+ *
+ * TEEC_VALUE_INPUT            The Parameter is a TEEC_Value tagged as input.
+ *
+ * TEEC_VALUE_OUTPUT           The Parameter is a TEEC_Value tagged as output.
+ *
+ * TEEC_VALUE_INOUT            The Parameter is a TEEC_Value tagged as both as
+ *                             input and output, i.e., for which both the
+ *                             behaviors of TEEC_VALUE_INPUT and
+ *                             TEEC_VALUE_OUTPUT apply.
+ *
+ * TEEC_MEMREF_TEMP_INPUT      The Parameter is a TEEC_TempMemoryReference
+ *                             describing a region of memory which needs to be
+ *                             temporarily registered for the duration of the
+ *                             Operation and is tagged as input.
+ *
+ * TEEC_MEMREF_TEMP_OUTPUT     Same as TEEC_MEMREF_TEMP_INPUT, but the Memory
+ *                             Reference is tagged as output. The
+ *                             Implementation may update the size field to
+ *                             reflect the required output size in some use
+ *                             cases.
+ *
+ * TEEC_MEMREF_TEMP_INOUT      A Temporary Memory Reference tagged as both
+ *                             input and output, i.e., for which both the
+ *                             behaviors of TEEC_MEMREF_TEMP_INPUT and
+ *                             TEEC_MEMREF_TEMP_OUTPUT apply.
+ *
+ * TEEC_MEMREF_WHOLE           The Parameter is a Registered Memory Reference
+ *                             that refers to the entirety of its parent Shared
+ *                             Memory block. The parameter structure is a
+ *                             TEEC_MemoryReference. In this structure, the
+ *                             Implementation MUST read only the parent field
+ *                             and MAY update the size field when the operation
+ *                             completes.
+ *
+ * TEEC_MEMREF_PARTIAL_INPUT   A Registered Memory Reference structure that
+ *                             refers to a partial region of its parent Shared
+ *                             Memory block and is tagged as input.
+ *
+ * TEEC_MEMREF_PARTIAL_OUTPUT  Registered Memory Reference structure that
+ *                             refers to a partial region of its parent Shared
+ *                             Memory block and is tagged as output.
+ *
+ * TEEC_MEMREF_PARTIAL_INOUT   The Registered Memory Reference structure that
+ *                             refers to a partial region of its parent Shared
+ *                             Memory block and is tagged as both input and
+ *                             output, i.e., for which both the behaviors of
+ *                             TEEC_MEMREF_PARTIAL_INPUT and
+ *                             TEEC_MEMREF_PARTIAL_OUTPUT apply.
+ */
+#define TEEC_NONE                   0x00000000
+#define TEEC_VALUE_INPUT            0x00000001
+#define TEEC_VALUE_OUTPUT           0x00000002
+#define TEEC_VALUE_INOUT            0x00000003
+#define TEEC_MEMREF_TEMP_INPUT      0x00000005
+#define TEEC_MEMREF_TEMP_OUTPUT     0x00000006
+#define TEEC_MEMREF_TEMP_INOUT      0x00000007
+#define TEEC_MEMREF_WHOLE           0x0000000C
+#define TEEC_MEMREF_PARTIAL_INPUT   0x0000000D
+#define TEEC_MEMREF_PARTIAL_OUTPUT  0x0000000E
+#define TEEC_MEMREF_PARTIAL_INOUT   0x0000000F
+
+/**
+ * Flag constants indicating the data transfer direction of memory in
+ * TEEC_Parameter. TEEC_MEM_INPUT signifies data transfer direction from the
+ * client application to the TEE. TEEC_MEM_OUTPUT signifies data transfer
+ * direction from the TEE to the client application. Type is uint32_t.
+ *
+ * TEEC_MEM_INPUT   The Shared Memory can carry data from the client
+ *                  application to the Trusted Application.
+ * TEEC_MEM_OUTPUT  The Shared Memory can carry data from the Trusted
+ *                  Application to the client application.
+ */
+#define TEEC_MEM_INPUT   0x00000001
+#define TEEC_MEM_OUTPUT  0x00000002
+
+/**
+ * Return values. Type is TEEC_Result
+ *
+ * TEEC_SUCCESS                 The operation was successful.
+ * TEEC_ERROR_GENERIC           Non-specific cause.
+ * TEEC_ERROR_ACCESS_DENIED     Access privileges are not sufficient.
+ * TEEC_ERROR_CANCEL            The operation was canceled.
+ * TEEC_ERROR_ACCESS_CONFLICT   Concurrent accesses caused conflict.
+ * TEEC_ERROR_EXCESS_DATA       Too much data for the requested operation was
+ *                              passed.
+ * TEEC_ERROR_BAD_FORMAT        Input data was of invalid format.
+ * TEEC_ERROR_BAD_PARAMETERS    Input parameters were invalid.
+ * TEEC_ERROR_BAD_STATE         Operation is not valid in the current state.
+ * TEEC_ERROR_ITEM_NOT_FOUND    The requested data item is not found.
+ * TEEC_ERROR_NOT_IMPLEMENTED   The requested operation should exist but is not
+ *                              yet implemented.
+ * TEEC_ERROR_NOT_SUPPORTED     The requested operation is valid but is not
+ *                              supported in this implementation.
+ * TEEC_ERROR_NO_DATA           Expected data was missing.
+ * TEEC_ERROR_OUT_OF_MEMORY     System ran out of resources.
+ * TEEC_ERROR_BUSY              The system is busy working on something else.
+ * TEEC_ERROR_COMMUNICATION     Communication with a remote party failed.
+ * TEEC_ERROR_SECURITY          A security fault was detected.
+ * TEEC_ERROR_SHORT_BUFFER      The supplied buffer is too short for the
+ *                              generated output.
+ * TEEC_ERROR_TARGET_DEAD       Trusted Application has panicked
+ *                              during the operation.
+ */
+
+/**
+ *  Standard defined error codes.
+ */
+#define TEEC_SUCCESS                       0x00000000
+#define TEEC_ERROR_STORAGE_NOT_AVAILABLE   0xF0100003
+#define TEEC_ERROR_GENERIC                 0xFFFF0000
+#define TEEC_ERROR_ACCESS_DENIED           0xFFFF0001
+#define TEEC_ERROR_CANCEL                  0xFFFF0002
+#define TEEC_ERROR_ACCESS_CONFLICT         0xFFFF0003
+#define TEEC_ERROR_EXCESS_DATA             0xFFFF0004
+#define TEEC_ERROR_BAD_FORMAT              0xFFFF0005
+#define TEEC_ERROR_BAD_PARAMETERS          0xFFFF0006
+#define TEEC_ERROR_BAD_STATE               0xFFFF0007
+#define TEEC_ERROR_ITEM_NOT_FOUND          0xFFFF0008
+#define TEEC_ERROR_NOT_IMPLEMENTED         0xFFFF0009
+#define TEEC_ERROR_NOT_SUPPORTED           0xFFFF000A
+#define TEEC_ERROR_NO_DATA                 0xFFFF000B
+#define TEEC_ERROR_OUT_OF_MEMORY           0xFFFF000C
+#define TEEC_ERROR_BUSY                    0xFFFF000D
+#define TEEC_ERROR_COMMUNICATION           0xFFFF000E
+#define TEEC_ERROR_SECURITY                0xFFFF000F
+#define TEEC_ERROR_SHORT_BUFFER            0xFFFF0010
+#define TEEC_ERROR_EXTERNAL_CANCEL         0xFFFF0011
+#define TEEC_ERROR_TARGET_DEAD             0xFFFF3024
+
+/**
+ * Function error origins, of type TEEC_ErrorOrigin. These indicate where in
+ * the software stack a particular return value originates from.
+ *
+ * TEEC_ORIGIN_API          The error originated within the TEE Client API
+ *                          implementation.
+ * TEEC_ORIGIN_COMMS        The error originated within the underlying
+ *                          communications stack linking the rich OS with
+ *                          the TEE.
+ * TEEC_ORIGIN_TEE          The error originated within the common TEE code.
+ * TEEC_ORIGIN_TRUSTED_APP  The error originated within the Trusted Application
+ *                          code.
+ */
+#define TEEC_ORIGIN_API          0x00000001
+#define TEEC_ORIGIN_COMMS        0x00000002
+#define TEEC_ORIGIN_TEE          0x00000003
+#define TEEC_ORIGIN_TRUSTED_APP  0x00000004
+
+/**
+ * Session login methods, for use in TEEC_OpenSession() as parameter
+ * connectionMethod. Type is uint32_t.
+ *
+ * TEEC_LOGIN_PUBLIC    	 No login data is provided.
+ * TEEC_LOGIN_USER         	Login data about the user running the Client
+ *                         	Application process is provided.
+ * TEEC_LOGIN_GROUP        	Login data about the group running the Client
+ *                         	Application process is provided.
+ * TEEC_LOGIN_APPLICATION  	Login data about the running Client Application
+ *                         	itself is provided.
+ * TEEC_LOGIN_USER_APPLICATION  Login data about the user and the running
+ *                          	Client Application itself is provided.
+ * TEEC_LOGIN_GROUP_APPLICATION Login data about the group and the running
+ *                          	Client Application itself is provided.
+ */
+#define TEEC_LOGIN_PUBLIC       0x00000000
+#define TEEC_LOGIN_USER         0x00000001
+#define TEEC_LOGIN_GROUP        0x00000002
+#define TEEC_LOGIN_APPLICATION  0x00000004
+#define TEEC_LOGIN_USER_APPLICATION  0x00000005
+#define TEEC_LOGIN_GROUP_APPLICATION  0x00000006
+
+/**
+ * Encode the paramTypes according to the supplied types.
+ *
+ * @param p0 The first param type.
+ * @param p1 The second param type.
+ * @param p2 The third param type.
+ * @param p3 The fourth param type.
+ */
+#define TEEC_PARAM_TYPES(p0, p1, p2, p3) \
+	((p0) | ((p1) << 4) | ((p2) << 8) | ((p3) << 12))
+
+/**
+ * Get the i_th param type from the paramType.
+ *
+ * @param p The paramType.
+ * @param i The i-th parameter to get the type for.
+ */
+#define TEEC_PARAM_TYPE_GET(p, i) (((p) >> (i * 4)) & 0xF)
+
+typedef uint32_t TEEC_Result;
+
+/**
+ * struct TEEC_Context - Represents a connection between a client application
+ * and a TEE.
+ */
+typedef struct {
+	/* Implementation defined */
+	int fd;
+	bool reg_mem;
+} TEEC_Context;
+
+/**
+ * This type contains a Universally Unique Resource Identifier (UUID) type as
+ * defined in RFC4122. These UUID values are used to identify Trusted
+ * Applications.
+ */
+typedef struct {
+	uint32_t timeLow;
+	uint16_t timeMid;
+	uint16_t timeHiAndVersion;
+	uint8_t clockSeqAndNode[8];
+} TEEC_UUID;
+
+/**
+ * struct TEEC_SharedMemory - Memory to transfer data between a client
+ * application and trusted code.
+ *
+ * @param buffer      The memory buffer which is to be, or has been, shared
+ *                    with the TEE.
+ * @param size        The size, in bytes, of the memory buffer.
+ * @param flags       Bit-vector which holds properties of buffer.
+ *                    The bit-vector can contain either or both of the
+ *                    TEEC_MEM_INPUT and TEEC_MEM_OUTPUT flags.
+ *
+ * A shared memory block is a region of memory allocated in the context of the
+ * client application memory space that can be used to transfer data between
+ * that client application and a trusted application. The user of this struct
+ * is responsible to populate the buffer pointer.
+ */
+typedef struct {
+	void *buffer;
+	size_t size;
+	uint32_t flags;
+	/*
+	 * Implementation-Defined
+	 */
+	int id;
+	size_t alloced_size;
+	void *shadow_buffer;
+	int registered_fd;
+	bool buffer_allocated;
+} TEEC_SharedMemory;
+
+/**
+ * struct TEEC_TempMemoryReference - Temporary memory to transfer data between
+ * a client application and trusted code, only used for the duration of the
+ * operation.
+ *
+ * @param buffer  The memory buffer which is to be, or has been shared with
+ *                the TEE.
+ * @param size    The size, in bytes, of the memory buffer.
+ *
+ * A memory buffer that is registered temporarily for the duration of the
+ * operation to be called.
+ */
+typedef struct {
+	void *buffer;
+	size_t size;
+} TEEC_TempMemoryReference;
+
+/**
+ * struct TEEC_RegisteredMemoryReference - use a pre-registered or
+ * pre-allocated shared memory block of memory to transfer data between
+ * a client application and trusted code.
+ *
+ * @param parent  Points to a shared memory structure. The memory reference
+ *                may utilize the whole shared memory or only a part of it.
+ *                Must not be NULL
+ *
+ * @param size    The size, in bytes, of the memory buffer.
+ *
+ * @param offset  The offset, in bytes, of the referenced memory region from
+ *                the start of the shared memory block.
+ *
+ */
+typedef struct {
+	TEEC_SharedMemory *parent;
+	size_t size;
+	size_t offset;
+} TEEC_RegisteredMemoryReference;
+
+/**
+ * struct TEEC_Value - Small raw data container
+ *
+ * Instead of allocating a shared memory buffer this structure can be used
+ * to pass small raw data between a client application and trusted code.
+ *
+ * @param a  The first integer value.
+ *
+ * @param b  The second value.
+ */
+typedef struct {
+	uint32_t a;
+	uint32_t b;
+} TEEC_Value;
+
+/**
+ * union TEEC_Parameter - Memory container to be used when passing data between
+ *                        client application and trusted code.
+ *
+ * Either the client uses a shared memory reference, parts of it or a small raw
+ * data container.
+ *
+ * @param tmpref  A temporary memory reference only valid for the duration
+ *                of the operation.
+ *
+ * @param memref  The entire shared memory or parts of it.
+ *
+ * @param value   The small raw data container to use
+ */
+typedef union {
+	TEEC_TempMemoryReference tmpref;
+	TEEC_RegisteredMemoryReference memref;
+	TEEC_Value value;
+} TEEC_Parameter;
+
+/**
+ * struct TEEC_Session - Represents a connection between a client application
+ * and a trusted application.
+ */
+typedef struct {
+	/* Implementation defined */
+	TEEC_Context *ctx;
+	uint32_t session_id;
+} TEEC_Session;
+
+/**
+ * struct TEEC_Operation - Holds information and memory references used in
+ * TEEC_InvokeCommand().
+ *
+ * @param   started     Client must initialize to zero if it needs to cancel
+ *                      an operation about to be performed.
+ * @param   paramTypes  Type of data passed. Use TEEC_PARAMS_TYPE macro to
+ *                      create the correct flags.
+ *                      0 means TEEC_NONE is passed for all params.
+ * @param   params      Array of parameters of type TEEC_Parameter.
+ * @param   session     Internal pointer to the last session used by
+ *                      TEEC_InvokeCommand with this operation.
+ *
+ */
+typedef struct {
+	uint32_t started;
+	uint32_t paramTypes;
+	TEEC_Parameter params[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+	/* Implementation-Defined */
+	TEEC_Session *session;
+} TEEC_Operation;
+
+/**
+ * TEEC_InitializeContext() - Initializes a context holding connection
+ * information on the specific TEE, designated by the name string.
+
+ * @param name    A zero-terminated string identifying the TEE to connect to.
+ *                If name is set to NULL, the default TEE is connected to. NULL
+ *                is the only supported value in this version of the API
+ *                implementation.
+ *
+ * @param context The context structure which is to be initialized.
+ *
+ * @return TEEC_SUCCESS  The initialization was successful.
+ * @return TEEC_Result   Something failed.
+ */
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *context);
+
+/**
+ * TEEC_FinalizeContext() - Destroys a context holding connection information
+ * on the specific TEE.
+ *
+ * This function destroys an initialized TEE context, closing the connection
+ * between the client application and the TEE. This function must only be
+ * called when all sessions related to this TEE context have been closed and
+ * all shared memory blocks have been released.
+ *
+ * @param context       The context to be destroyed.
+ */
+void TEEC_FinalizeContext(TEEC_Context *context);
+
+/**
+ * TEEC_OpenSession() - Opens a new session with the specified trusted
+ *                      application.
+ *
+ * @param context            The initialized TEE context structure in which
+ *                           scope to open the session.
+ * @param session            The session to initialize.
+ * @param destination        A structure identifying the trusted application
+ *                           with which to open a session.
+ *
+ * @param connectionMethod   The connection method to use.
+ * @param connectionData     Any data necessary to connect with the chosen
+ *                           connection method. Not supported, should be set to
+ *                           NULL.
+ * @param operation          An operation structure to use in the session. May
+ *                           be set to NULL to signify no operation structure
+ *                           needed.
+ *
+ * @param returnOrigin       A parameter which will hold the error origin if
+ *                           this function returns any value other than
+ *                           TEEC_SUCCESS.
+ *
+ * @return TEEC_SUCCESS      OpenSession successfully opened a new session.
+ * @return TEEC_Result       Something failed.
+ *
+ */
+TEEC_Result TEEC_OpenSession(TEEC_Context *context,
+			     TEEC_Session *session,
+			     const TEEC_UUID *destination,
+			     uint32_t connectionMethod,
+			     const void *connectionData,
+			     TEEC_Operation *operation,
+			     uint32_t *returnOrigin);
+
+/**
+ * TEEC_CloseSession() - Closes the session which has been opened with the
+ * specific trusted application.
+ *
+ * @param session The opened session to close.
+ */
+void TEEC_CloseSession(TEEC_Session *session);
+
+/**
+ * TEEC_InvokeCommand() - Executes a command in the specified trusted
+ * application.
+ *
+ * @param session        A handle to an open connection to the trusted
+ *                       application.
+ * @param commandID      Identifier of the command in the trusted application
+ *                       to invoke.
+ * @param operation      An operation structure to use in the invoke command.
+ *                       May be set to NULL to signify no operation structure
+ *                       needed.
+ * @param returnOrigin   A parameter which will hold the error origin if this
+ *                       function returns any value other than TEEC_SUCCESS.
+ *
+ * @return TEEC_SUCCESS  OpenSession successfully opened a new session.
+ * @return TEEC_Result   Something failed.
+ */
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session,
+			       uint32_t commandID,
+			       TEEC_Operation *operation,
+			       uint32_t *returnOrigin);
+
+/**
+ * TEEC_RegisterSharedMemory() - Register a block of existing memory as a
+ * shared block within the scope of the specified context.
+ *
+ * @param context    The initialized TEE context structure in which scope to
+ *                   open the session.
+ * @param sharedMem  pointer to the shared memory structure to register.
+ *
+ * @return TEEC_SUCCESS              The registration was successful.
+ * @return TEEC_ERROR_OUT_OF_MEMORY  Memory exhaustion.
+ * @return TEEC_Result               Something failed.
+ */
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *context,
+				      TEEC_SharedMemory *sharedMem);
+
+/**
+ * TEEC_AllocateSharedMemory() - Allocate shared memory for TEE.
+ *
+ * @param context     The initialized TEE context structure in which scope to
+ *                    open the session.
+ * @param sharedMem   Pointer to the allocated shared memory.
+ *
+ * @return TEEC_SUCCESS              The registration was successful.
+ * @return TEEC_ERROR_OUT_OF_MEMORY  Memory exhaustion.
+ * @return TEEC_Result               Something failed.
+ */
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *context,
+				      TEEC_SharedMemory *sharedMem);
+
+/**
+ * TEEC_ReleaseSharedMemory() - Free or deregister the shared memory.
+ *
+ * @param sharedMem  Pointer to the shared memory to be freed.
+ */
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *sharedMemory);
+
+/**
+ * TEEC_RequestCancellation() - Request the cancellation of a pending open
+ *                              session or command invocation.
+ *
+ * @param operation Pointer to an operation previously passed to open session
+ *                  or invoke.
+ */
+void TEEC_RequestCancellation(TEEC_Operation *operation);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/activation_layer.c b/third_party/optee_delegate/darknet_ca/src/activation_layer.c
new file mode 100644
index 0000000..282235b
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/activation_layer.c
@@ -0,0 +1,33 @@
+#include "activation_layer.h"
+#include "utils.h"
+#include "blas.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+layer make_activation_layer(int batch, int inputs, ACTIVATION activation)
+{
+    layer l = {0};
+    l.type = ACTIVE;
+
+    l.inputs = inputs;
+    l.outputs = inputs;
+    l.batch=batch;
+
+    l.output = calloc(batch*inputs, sizeof(float*));
+
+    l.forward = forward_activation_layer;
+    l.activation = activation;
+    LOGD("Activation Layer: %d inputs\n", inputs);
+    return l;
+}
+
+void forward_activation_layer(layer l, network net)
+{
+    copy_cpu(l.outputs*l.batch, net.input, 1, l.output, 1);
+    activate_array(l.output, l.outputs*l.batch, l.activation);
+    DUMPW8("activation output bytes:",l.outputs, l.output);
+    DUMPW4F("activation output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/activation_layer.h b/third_party/optee_delegate/darknet_ca/src/activation_layer.h
new file mode 100644
index 0000000..875c7b1
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/activation_layer.h
@@ -0,0 +1,13 @@
+#ifndef ACTIVATION_LAYER_H
+#define ACTIVATION_LAYER_H
+
+#include "activations.h"
+#include "layer.h"
+#include "network.h"
+
+layer make_activation_layer(int batch, int inputs, ACTIVATION activation);
+
+void forward_activation_layer(layer l, network net);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/activations.c b/third_party/optee_delegate/darknet_ca/src/activations.c
new file mode 100644
index 0000000..b99b616
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/activations.c
@@ -0,0 +1,51 @@
+#include "activations.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+char *get_activation_string(ACTIVATION a)
+{
+    switch(a){
+        case RELU:
+            return "relu";
+        case RELU6:
+            return "relu6";
+        case NOACT:
+            return "noact";
+        default:
+            break;
+    }
+    return "relu";
+}
+
+ACTIVATION get_activation(char *s)
+{
+    if (strcmp(s, "relu")==0) return RELU;
+    if (strcmp(s, "relu6")==0) return RELU6;
+    if (strcmp(s, "noact")==0) return NOACT;
+    fprintf(stderr, "Couldn't find activation function %s, going with ReLU\n", s);
+    return RELU;
+}
+
+float activate(float x, ACTIVATION a)
+{
+    switch(a){
+        case RELU:
+            return relu_activate(x);
+        case RELU6:
+            return relu6_activate(x);
+        case NOACT:
+            return noact_activate(x);
+    }
+    return 0;
+}
+
+void activate_array(float *x, const int n, const ACTIVATION a)
+{
+    int i;
+    for(i = 0; i < n; ++i){
+        x[i] = activate(x[i], a);
+    }
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/activations.h b/third_party/optee_delegate/darknet_ca/src/activations.h
new file mode 100644
index 0000000..39c199d
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/activations.h
@@ -0,0 +1,18 @@
+#ifndef ACTIVATIONS_H
+#define ACTIVATIONS_H
+#include "darknet.h"
+#include "math.h"
+
+ACTIVATION get_activation(char *s);
+
+char *get_activation_string(ACTIVATION a);
+float activate(float x, ACTIVATION a);
+void activate_array(float *x, const int n, const ACTIVATION a);
+
+static inline float relu_activate(float x){return x*(x>0);}
+static inline float relu6_activate(float x){return (x < 0.) ? 0 : (6.0 < x) ? 6.0: x;}
+static inline float tanh_activate(float x){return (exp(2*x)-1)/(exp(2*x)+1);}
+/* output = input; no activation */
+static inline float noact_activate(float x){return x;}
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/add_mask_layer.c b/third_party/optee_delegate/darknet_ca/src/add_mask_layer.c
new file mode 100644
index 0000000..fb93683
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/add_mask_layer.c
@@ -0,0 +1,47 @@
+#include "add_mask_layer.h"
+#include "utils.h"
+#include "blas.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+layer make_add_mask_layer(int batch, int h, int w, int c)
+{
+    layer l = {0};
+    l.type = ADD_MASK;
+
+    l.h = h;
+    l.w = w;
+    l.c = c;
+    l.inputs = h * w * c;
+    l.outputs = l.inputs;
+    l.batch=batch;
+
+    l.out_h = h;
+    l.out_w = w;
+    l.out_c = c;
+    l.output = calloc(batch*l.inputs, sizeof(float));
+    l.weights = calloc(l.inputs, sizeof(float));
+    l.rscalar = calloc(1, sizeof(float));
+
+    l.forward = forward_add_mask_layer;
+    LOGD("Add_Mask Layer: %d inputs\n", l.inputs);
+    return l;
+}
+
+void forward_add_mask_layer(layer l, network net)
+{
+    fill_cpu(l.outputs*l.batch, 0, l.output, 1);
+    int m = l.batch;
+    int k = l.inputs;
+    int i, j;
+    for (i = 0; i < m; ++i){
+        for (j = 0; j < k; ++j) {
+            l.output[i * k + j] = net.input[i * k + j] + l.weights[j] * l.rscalar[0]; 
+        }
+    }
+    DUMPW8("add_mask output bytes:",l.outputs, l.output);
+    DUMPW4F("add_mask output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/add_mask_layer.h b/third_party/optee_delegate/darknet_ca/src/add_mask_layer.h
new file mode 100644
index 0000000..95b0251
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/add_mask_layer.h
@@ -0,0 +1,12 @@
+#ifndef ADD_MASK_LAYER_H
+#define ADD_MASK_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+layer make_add_mask_layer(int batch, int h, int w, int c);
+
+void forward_add_mask_layer(layer l, network net);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/avgpool_layer.c b/third_party/optee_delegate/darknet_ca/src/avgpool_layer.c
new file mode 100644
index 0000000..56cc831
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/avgpool_layer.c
@@ -0,0 +1,54 @@
+#include "avgpool_layer.h"
+#include "utils.h"
+#include <stdio.h>
+
+avgpool_layer make_avgpool_layer(int batch, int w, int h, int c)
+{
+    fprintf(stderr, "avg                     %4d x%4d x%4d   ->  %4d\n",  w, h, c, c);
+    avgpool_layer l = {0};
+    l.type = AVGPOOL;
+    l.batch = batch;
+    l.h = h;
+    l.w = w;
+    l.c = c;
+    l.out_w = 1;
+    l.out_h = 1;
+    l.out_c = c;
+    l.outputs = l.out_c;
+    l.inputs = h*w*c;
+    int output_size = l.outputs * batch;
+    l.output =  calloc(output_size, sizeof(float));
+    l.forward = forward_avgpool_layer;
+    return l;
+}
+
+void resize_avgpool_layer(avgpool_layer *l, int w, int h)
+{
+    l->w = w;
+    l->h = h;
+    l->inputs = h*w*l->c;
+}
+
+void forward_avgpool_layer(const avgpool_layer l, network net)
+{
+    int b,i,k;
+    int out_index,in_index;
+
+    for(b = 0; b < l.batch; ++b){
+        for(k = 0; k < l.c; ++k){
+            out_index = k + b*l.c;
+            l.output[out_index] = 0;
+            for(i = 0; i < l.h*l.w; ++i){
+                if (l.nhwc == 1)
+                    in_index = k + l.c*(i + b*l.h*l.w); 
+                else
+                    in_index = i + l.h*l.w*(k + b*l.c);
+
+                l.output[out_index] += net.input[in_index];
+            }
+            l.output[out_index] /= l.h*l.w;
+        }
+    }
+    DUMPW8("avgpool output bytes:",l.outputs, l.output);
+    DUMPW4F("avgpool output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/avgpool_layer.h b/third_party/optee_delegate/darknet_ca/src/avgpool_layer.h
new file mode 100644
index 0000000..7c153c6
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/avgpool_layer.h
@@ -0,0 +1,14 @@
+#ifndef AVGPOOL_LAYER_H
+#define AVGPOOL_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+typedef layer avgpool_layer;
+
+avgpool_layer make_avgpool_layer(int batch, int w, int h, int c);
+void resize_avgpool_layer(avgpool_layer *l, int w, int h);
+void forward_avgpool_layer(const avgpool_layer l, network net);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.c b/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.c
new file mode 100644
index 0000000..15f08ee
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.c
@@ -0,0 +1,99 @@
+#include "batchnorm_layer.h"
+#include "blas.h"
+#include "utils.h"
+#include <stdio.h>
+
+void scale_bias(float *output, float *scales, int batch, int n, int size)
+{
+    int i,j,b;
+    for(b = 0; b < batch; ++b){
+        for(i = 0; i < n; ++i){
+            for(j = 0; j < size; ++j){
+                output[(b*n + i)*size + j] *= scales[i];
+            }
+        }
+    }
+}
+
+void scale_bias_nhwc(float *output, float *scales, int batch, int n, int size)
+{
+    int i,j,b;
+    for(b = 0; b < batch; ++b){
+        for(i = 0; i < n; ++i){
+            for(j = 0; j < size; ++j){
+                output[(b*size + j)*n + i] *= scales[i];
+            }
+        }
+    }
+}
+void add_bias(float *output, float *biases, int batch, int n, int size)
+{
+    int i,j,b;
+    for(b = 0; b < batch; ++b){
+        for(i = 0; i < n; ++i){
+            for(j = 0; j < size; ++j){
+                output[(b*n + i)*size + j] += biases[i];
+            }
+        }
+    }
+}
+
+void add_bias_nhwc(float *output, float *biases, int batch, int n, int size)
+{
+    int i,j,b;
+    for(b = 0; b < batch; ++b){
+        for(i = 0; i < n; ++i){
+            for(j = 0; j < size; ++j){
+                output[(b*size + j)*n + i] += biases[i];
+            }
+        }
+    }
+}
+
+layer make_batchnorm_layer(int batch, int w, int h, int c)
+{
+    LOGD("Batch Normalization Layer: %d x %d x %d image\n", w,h,c);
+    layer l = {0};
+    l.type = BATCHNORM;
+    l.batch = batch;
+    l.h = l.out_h = h;
+    l.w = l.out_w = w;
+    l.c = l.out_c = c;
+    l.output = calloc(h * w * c * batch, sizeof(float));
+    l.inputs = w*h*c;
+    l.outputs = l.inputs;
+
+    l.scales = calloc(c, sizeof(float));
+    l.biases = calloc(c, sizeof(float));
+    int i;
+    for(i = 0; i < c; ++i){
+        l.scales[i] = 1;
+    }
+
+    l.rolling_mean = calloc(c, sizeof(float));
+    l.rolling_variance = calloc(c, sizeof(float));
+
+    l.forward = forward_batchnorm_layer;
+    return l;
+}
+
+void forward_batchnorm_layer(layer l, network net)
+{
+    printf("forward_bn\n");
+    if(l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, net.input, 1, l.output, 1);
+    if (l.nhwc == 1) {
+        normalize_cpu_nhwc(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.out_c, l.out_h*l.out_w);
+    } else {
+        normalize_cpu(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.out_c, l.out_h*l.out_w);
+    }
+    if (l.nhwc == 1) {
+        scale_bias_nhwc(l.output, l.scales, l.batch, l.out_c, l.out_h*l.out_w);
+        add_bias_nhwc(l.output, l.biases, l.batch, l.out_c, l.out_h*l.out_w);
+    } else {
+        scale_bias(l.output, l.scales, l.batch, l.out_c, l.out_h*l.out_w);
+        add_bias(l.output, l.biases, l.batch, l.out_c, l.out_h*l.out_w);
+    }
+
+    DUMPW8("batchnorm output bytes:",l.outputs, l.output);
+    DUMPW4F("batchnorm output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.h b/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.h
new file mode 100644
index 0000000..b022202
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/batchnorm_layer.h
@@ -0,0 +1,10 @@
+#ifndef BATCHNORM_LAYER_H
+#define BATCHNORM_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+layer make_batchnorm_layer(int batch, int w, int h, int c);
+void forward_batchnorm_layer(layer l, network net);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/blas.c b/third_party/optee_delegate/darknet_ca/src/blas.c
new file mode 100644
index 0000000..70c1c2a
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/blas.c
@@ -0,0 +1,111 @@
+#include "blas.h"
+
+#include <math.h>
+#include <assert.h>
+#include <float.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+void mean_cpu(float *x, int batch, int filters, int spatial, float *mean)
+{
+    float scale = 1./(batch * spatial);
+    int i,j,k;
+    for(i = 0; i < filters; ++i){
+        mean[i] = 0;
+        for(j = 0; j < batch; ++j){
+            for(k = 0; k < spatial; ++k){
+                int index = j*filters*spatial + i*spatial + k;
+                mean[i] += x[index];
+            }
+        }
+        mean[i] *= scale;
+    }
+}
+
+void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)
+{
+    float scale = 1./(batch * spatial - 1);
+    int i,j,k;
+    for(i = 0; i < filters; ++i){
+        variance[i] = 0;
+        for(j = 0; j < batch; ++j){
+            for(k = 0; k < spatial; ++k){
+                int index = j*filters*spatial + i*spatial + k;
+                variance[i] += pow((x[index] - mean[i]), 2);
+            }
+        }
+        variance[i] *= scale;
+    }
+}
+
+
+void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)
+{
+    int b, f, i;
+    for(b = 0; b < batch; ++b){
+        for(f = 0; f < filters; ++f){
+            for(i = 0; i < spatial; ++i){
+                int index = b*filters*spatial + f*spatial + i;
+                x[index] = (x[index] - mean[f])/(sqrt(variance[f]) + .000001f);
+            }
+        }
+    }
+}
+
+void normalize_cpu_nhwc(float *x, float *mean, float *variance, int batch, int filters, int spatial)
+{
+    int b, f, i;
+    for(b = 0; b < batch; ++b){
+        for(f = 0; f < filters; ++f){
+            for(i = 0; i < spatial; ++i){
+                int index = b*filters*spatial + i*filters+ f;
+                //x[index] = (x[index] - mean[f])/(sqrt(variance[f]) + .000001f);
+                x[index] = (x[index] - mean[f])/(sqrt(variance[f] + .001f));
+            }
+        }
+    }
+}
+
+
+void fill_cpu(int N, float ALPHA, float *X, int INCX)
+{
+    int i;
+    for(i = 0; i < N; ++i) X[i*INCX] = ALPHA;
+}
+
+void copy_cpu(int N, float *X, int INCX, float *Y, int INCY)
+{
+    int i;
+    for(i = 0; i < N; ++i) Y[i*INCY] = X[i*INCX];
+}
+
+void softmax(float *input, int n, float temp, int stride, float *output)
+{
+    int i;
+    float sum = 0;
+    float largest = -FLT_MAX;
+    for(i = 0; i < n; ++i){
+        if(input[i*stride] > largest) largest = input[i*stride];
+    }
+    for(i = 0; i < n; ++i){
+        float e = exp(input[i*stride]/temp - largest/temp);
+        sum += e;
+        output[i*stride] = e;
+    }
+    for(i = 0; i < n; ++i){
+        output[i*stride] /= sum;
+    }
+}
+
+
+void softmax_cpu(float *input, int n, int batch, int batch_offset, int groups, int group_offset, int stride, float temp, float *output)
+{
+    int g, b;
+    for(b = 0; b < batch; ++b){
+        for(g = 0; g < groups; ++g){
+            softmax(input + b*batch_offset + g*group_offset, n, temp, stride, output + b*batch_offset + g*group_offset);
+        }
+    }
+}
+
diff --git a/third_party/optee_delegate/darknet_ca/src/blas.h b/third_party/optee_delegate/darknet_ca/src/blas.h
new file mode 100644
index 0000000..013e958
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/blas.h
@@ -0,0 +1,18 @@
+#ifndef BLAS_H
+#define BLAS_H
+#include "darknet.h"
+
+
+void test_blas();
+
+
+void mean_cpu(float *x, int batch, int filters, int spatial, float *mean);
+void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance);
+
+void scale_bias(float *output, float *scales, int batch, int n, int size);
+void scale_bias_nhwc(float *output, float *scales, int batch, int n, int size);
+
+void softmax(float *input, int n, float temp, int stride, float *output);
+void softmax_cpu(float *input, int n, int batch, int batch_offset, int groups, int group_offset, int stride, float temp, float *output);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/ca_cmds.c b/third_party/optee_delegate/darknet_ca/src/ca_cmds.c
new file mode 100644
index 0000000..e56bda9
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/ca_cmds.c
@@ -0,0 +1,186 @@
+#include "ca_cmds.h"
+#include "utils.h"
+
+void setup_tee_session(void);
+void teardown_tee_session(void);
+TEEC_Context ctx;
+TEEC_Session sess;
+TEEC_SharedMemory shm;
+int tee_initialized = 0;
+
+int parse_network_cfg_ca_cmd(char *cfg_buf) {
+  TEEC_Operation op;
+  TEEC_Result res;
+  uint32_t origin;
+  int ta_netid = -1;
+
+  if (tee_initialized == 0) {
+      setup_tee_session();
+      tee_initialized = 1;
+  }
+
+  memset(&op, 0, sizeof(op));
+  op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INOUT,
+                                   TEEC_NONE, TEEC_NONE);
+
+  op.params[0].tmpref.buffer = cfg_buf;
+  op.params[0].tmpref.size = strlen(cfg_buf); 
+
+  op.params[1].value.a = -1;
+
+  res = TEEC_InvokeCommand(&sess, CMD_PARSE_NETWORK_CFG,
+                           &op, &origin);
+
+  if (res != TEEC_SUCCESS)
+  errx(1, "TEEC_InvokeCommand(PARSE_NETWORK_CFG) failed 0x%x origin 0x%x",
+       res, origin);
+  else
+      ta_netid = op.params[1].value.a;
+  
+  //LOGD("ca netid:%d ", ta_netid);
+
+  return ta_netid;
+}
+
+void load_weights_ca_cmd_unit(int ta_netid, int layer_id, void *weights, int weight_idx, size_t length, size_t offset); 
+
+#define MB  (1024*1024)
+
+void load_weights_ca_cmd(int ta_netid, int layer_id, void *weights, int weight_idx, size_t length)
+{
+  void *cur = NULL;
+  int offset, left, payload;
+
+  //LOGD("load_weights_ca_cmd");
+  //LOGD("load_weights: weigths:%p, length:%d,ta_netid:%d,lid:%d,idx:%d,length:%d",weights,length,ta_netid,layer_id,weight_idx,length);
+  if (length > MB) {
+      left = length;
+      offset = 0;
+      while (left > 0) {
+          if (left > MB) {
+            payload = MB; 
+          } else
+              payload = left;
+
+          cur = (uint8_t *)weights + offset;
+          load_weights_ca_cmd_unit(ta_netid, layer_id, cur, weight_idx, payload, offset);
+          offset += payload;
+          left -= payload;
+      }
+  } else {
+    load_weights_ca_cmd_unit(ta_netid, layer_id, weights, weight_idx, length, 0);
+  }
+  return;
+      
+}
+
+void load_weights_ca_cmd_unit(int ta_netid, int layer_id, void *weights, int weight_idx, size_t length, size_t offset) {
+  TEEC_Operation op;
+  TEEC_Result res;
+  uint32_t origin;
+
+  memset(&op, 0, sizeof(op));
+  op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_VALUE_INOUT,
+                                   TEEC_VALUE_INOUT, TEEC_VALUE_INOUT);
+
+  //LOGD("load_weights: weigths:%p, length:%d,ta_netid:%d,lid:%d,idx:%d,length:%d, offset:%d ",weights,length,ta_netid,layer_id,weight_idx,length,offset);
+  op.params[0].tmpref.buffer = weights;
+  op.params[0].tmpref.size = length; 
+
+  op.params[1].value.a = ta_netid;
+  op.params[1].value.b = layer_id;
+
+  op.params[2].value.a = weight_idx;
+  op.params[2].value.b = length;
+
+  op.params[3].value.a = offset;
+
+  res = TEEC_InvokeCommand(&sess, CMD_LOAD_WEIGHTS,
+                           &op, &origin);
+
+  if (res != TEEC_SUCCESS)
+  errx(1, "TEEC_InvokeCommand(LOAD_WEIGHTS) failed 0x%x origin 0x%x",
+       res, origin);
+}
+
+void network_predict_ca_cmd(int ta_netid, void *input, int in_len, void *output, int out_len)
+{
+  TEEC_Operation op;
+  TEEC_Result res;
+  uint32_t origin;
+  //LOGD("predict ca cmd : input:%p, length:%d,ta_netid:%d,output:%p,len:%d",input,in_len,ta_netid,output,out_len);
+
+  memset(&op, 0, sizeof(op));
+  //LOGD("%s, after memset, after input",__func__);
+  //op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_PARTIAL_INOUT,
+  op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT, TEEC_NONE,
+                                   TEEC_VALUE_INOUT, TEEC_NONE);
+  //LOGD("%s, after params, after input",__func__);
+
+  op.params[0].tmpref.buffer = input;
+  op.params[0].tmpref.size = in_len; 
+
+  //shm.buffer = output;
+  //shm.size = out_len;
+  //shm.flags = TEEC_MEM_INPUT|TEEC_MEM_OUTPUT;
+  //res = TEEC_RegisterSharedMemory(&ctx, &shm);
+  //if (res != TEEC_SUCCESS) {
+  //  LOGD("TEEC_InvokeCommand(ReigsterSharedMemory) failed 0x%x origin 0x%x",
+  //     res, origin);
+  //  return;
+  //} else
+  //    LOGD("register shared memory success!");
+
+  //LOGD("%s, before invoke, after input",__func__);
+ // op.params[1].memref.parent = &shm;
+ // op.params[1].memref.offset = 0;
+ // op.params[1].memref.size = out_len;
+ // op.params[1].memref.size = out_len;
+
+  op.params[2].value.a = ta_netid;
+  op.params[2].value.b = out_len;
+
+  //LOGD("%s, before invoke",__func__);
+  res = TEEC_InvokeCommand(&sess, CMD_NETWORK_PREDICT,
+                           &op, &origin);
+
+  if (res != TEEC_SUCCESS)
+  LOGD("TEEC_InvokeCommand(NETWORK_PREDICT) failed 0x%x origin 0x%x",
+       res, origin);
+
+  // reuse input buffer for output in tee and then copy out
+  memcpy(output, input, out_len);
+  //LOGD("return predict");
+
+  //LOGD("close tee to release memory");
+  teardown_tee_session();
+  tee_initialized = 0;
+}
+
+void setup_tee_session(void)
+{
+    TEEC_UUID uuid = TA_TEE_SHADOW_UUID;
+    TEEC_Result res;
+    uint32_t origin;
+
+    /* Initialize a context connecting us to the TEE */
+    res = TEEC_InitializeContext(NULL, &ctx);
+    if (res != TEEC_SUCCESS)
+    errx(1, "TEEC_InitializeContext failed with code 0x%x", res);
+
+    /* Open a session with the TA */
+    res = TEEC_OpenSession(&ctx, &sess, &uuid,
+                           TEEC_LOGIN_PUBLIC, NULL, NULL, &origin);
+    if (res != TEEC_SUCCESS)
+    errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x",
+         res, origin);
+
+
+}
+
+void teardown_tee_session(void)
+{
+    TEEC_CloseSession(&sess);
+    TEEC_FinalizeContext(&ctx);
+}
+
diff --git a/third_party/optee_delegate/darknet_ca/src/ca_cmds.h b/third_party/optee_delegate/darknet_ca/src/ca_cmds.h
new file mode 100644
index 0000000..e5e03d7
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/ca_cmds.h
@@ -0,0 +1,18 @@
+#include <err.h>
+#include <stdio.h>
+#include <string.h>
+#include <tee_client_api.h>
+
+#define TA_HELLO_WORLD_UUID \
+        { 0x8aaaf200, 0x2450, 0x11e4, \
+                { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} }
+
+// TODO
+#define CMD_TEST                    0
+
+#define MODEL_SAFE_BASE             518 
+#define CMD_PARSE_NETWORK_CFG       (MODEL_SAFE_BASE + 0)
+#define CMD_LOAD_WEIGHTS            (MODEL_SAFE_BASE + 1) 
+#define CMD_NETWORK_PREDICT         (MODEL_SAFE_BASE + 2)
+
+#define TA_TEE_SHADOW_UUID           TA_HELLO_WORLD_UUID 
diff --git a/third_party/optee_delegate/darknet_ca/src/dropout_layer.c b/third_party/optee_delegate/darknet_ca/src/dropout_layer.c
new file mode 100644
index 0000000..6515700
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/dropout_layer.c
@@ -0,0 +1,18 @@
+#include "dropout_layer.h"
+#include "utils.h"
+#include <stdlib.h>
+#include <stdio.h>
+
+dropout_layer make_dropout_layer(int batch, int inputs, float probability)
+{
+    dropout_layer l = {0};
+    l.type = DROPOUT;
+    l.forward = forward_dropout_layer;
+    LOGD("dropout       p = %.2f               %4d  ->  %4d\n", probability, inputs, inputs);
+    return l;
+} 
+
+void forward_dropout_layer(dropout_layer l, network net)
+{
+    return;
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/dropout_layer.h b/third_party/optee_delegate/darknet_ca/src/dropout_layer.h
new file mode 100644
index 0000000..1902dc0
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/dropout_layer.h
@@ -0,0 +1,13 @@
+#ifndef DROPOUT_LAYER_H
+#define DROPOUT_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+typedef layer dropout_layer;
+
+dropout_layer make_dropout_layer(int batch, int inputs, float probability);
+
+void forward_dropout_layer(dropout_layer l, network net);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/layer.c b/third_party/optee_delegate/darknet_ca/src/layer.c
new file mode 100644
index 0000000..a10389d
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/layer.c
@@ -0,0 +1,20 @@
+#include "layer.h"
+
+#include <stdlib.h>
+
+void free_layer(layer l)
+{
+    if(l.type == DROPOUT){
+        return;
+    }
+    if(l.biases)             free(l.biases);
+    if(l.scales)             free(l.scales);
+    if(l.weights)            free(l.weights);
+    if(l.output)             free(l.output);
+    if(l.rolling_mean)       free(l.rolling_mean);
+    if(l.rolling_variance)   free(l.rolling_variance);
+    if(l.rscalar)            free(l.rscalar);
+    if(l.rbias)              free(l.rbias);
+    if(l.obfweights)         free(l.obfweights);
+
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/layer.h b/third_party/optee_delegate/darknet_ca/src/layer.h
new file mode 100644
index 0000000..af6cd2a
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/layer.h
@@ -0,0 +1 @@
+#include "darknet.h"
diff --git a/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.c b/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.c
new file mode 100644
index 0000000..8d27679
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.c
@@ -0,0 +1,65 @@
+#include "linear_transform_layer.h"
+#include "utils.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+layer make_linear_transform_layer(int batch, int h, int w, int c, int units)
+{
+    layer l = {0};
+    l.type = LINEAR_TRANSFORM;
+
+    l.batch = batch;
+    l.h = h;
+    l.w = w;
+    l.c = c;
+    l.units = units;
+    l.inputs = l.h * l.w * l.c;
+
+    l.out_h = h;
+    l.out_w = w;
+    l.out_c = units;
+    l.outputs = l.h * l.w * l.units;
+
+    l.output = calloc(batch*l.outputs, sizeof(float));
+    l.obfweights = calloc(2*l.units, sizeof(int));
+    l.rbias = calloc(l.units, sizeof(float));
+
+    l.forward = forward_linear_transform_layer;
+    LOGD("Linear_Transform Layer: %d inputs\n", l.inputs);
+    return l;
+}
+
+void forward_linear_transform_layer(layer l, network net)
+{
+    fill_cpu(l.outputs*l.batch, 0, l.output, 1);
+    int B = l.batch;
+    int H = l.h;
+    int W = l.w;
+    int M = l.c;
+    int N = l.units;
+
+    int b, h, w, n;
+    int idx_from, idx_rand;
+    float scalar;
+    for (b = 0; b < B; ++b){
+        for (h = 0; h < H; ++h) {
+            for (w = 0; w < W; ++w) {
+                for (n = 0; n < N; ++n) {
+                    idx_from = l.obfweights[n];
+                    idx_rand = l.obfweights[N + n];
+                    scalar = l.rbias[n];
+
+                    l.output[(b * H * W * N) + (h * W * N) + (w * N) + n] = 
+                      net.input[(b * H * W * M) + (h * W * M) + (w * M) + idx_from] * scalar +  
+                        net.input[(b * H * W * M) + (h * W * M) + (w * M) + idx_rand]; 
+                }
+            }
+        }
+    }
+
+    DUMPW8("linear_transform output bytes:",l.outputs, l.output);
+    DUMPW4F("linear_transform output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.h b/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.h
new file mode 100644
index 0000000..7dcfabe
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/linear_transform_layer.h
@@ -0,0 +1,12 @@
+#ifndef LINEAR_TRANSFORM_LAYER_H
+#define LINEAR_TRANSFORM_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+layer make_linear_transform_layer(int batch, int h, int w, int c, int units);
+
+void forward_linear_transform_layer(layer l, network net);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/list.c b/third_party/optee_delegate/darknet_ca/src/list.c
new file mode 100644
index 0000000..fc48ca5
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/list.c
@@ -0,0 +1,78 @@
+#include <stdlib.h>
+#include <string.h>
+#include "list.h"
+
+list *make_list()
+{
+	list *l = malloc(sizeof(list));
+	l->size = 0;
+	l->front = 0;
+	l->back = 0;
+	return l;
+}
+
+void *list_pop(list *l){
+    if(!l->back) return 0;
+    node *b = l->back;
+    void *val = b->val;
+    l->back = b->prev;
+    if(l->back) l->back->next = 0;
+    free(b);
+    --l->size;
+    
+    return val;
+}
+
+void list_insert(list *l, void *val)
+{
+	node *new = malloc(sizeof(node));
+	new->val = val;
+	new->next = 0;
+
+	if(!l->back){
+		l->front = new;
+		new->prev = 0;
+	}else{
+		l->back->next = new;
+		new->prev = l->back;
+	}
+	l->back = new;
+	++l->size;
+}
+
+void free_node(node *n)
+{
+	node *next;
+	while(n) {
+		next = n->next;
+		free(n);
+		n = next;
+	}
+}
+
+void free_list(list *l)
+{
+	free_node(l->front);
+	free(l);
+}
+
+void free_list_contents(list *l)
+{
+	node *n = l->front;
+	while(n){
+		free(n->val);
+		n = n->next;
+	}
+}
+
+void **list_to_array(list *l)
+{
+    void **a = calloc(l->size, sizeof(void*));
+    int count = 0;
+    node *n = l->front;
+    while(n){
+        a[count++] = n->val;
+        n = n->next;
+    }
+    return a;
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/list.h b/third_party/optee_delegate/darknet_ca/src/list.h
new file mode 100644
index 0000000..6b445c7
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/list.h
@@ -0,0 +1,13 @@
+#ifndef LIST_H
+#define LIST_H
+#include "darknet.h"
+
+list *make_list();
+int list_find(list *l, void *val);
+
+void list_insert(list *, void *);
+
+
+void free_list_contents(list *l);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/network.c b/third_party/optee_delegate/darknet_ca/src/network.c
new file mode 100644
index 0000000..e013495
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/network.c
@@ -0,0 +1,190 @@
+#include <stdio.h>
+#include <time.h>
+#include <assert.h>
+#include "network.h"
+#include "utils.h"
+#include "blas.h"
+
+#include "activation_layer.h"
+#include "batchnorm_layer.h"
+#include "avgpool_layer.h"
+#include "softmax_layer.h"
+#include "dropout_layer.h"
+#include "add_mask_layer.h"
+#include "linear_transform_layer.h"
+#include "shuffle_channel_layer.h"
+#include "parser.h"
+#include "ca_cmds.h"
+
+network *parse_network_cfg_ca(char *cfg); // declare before use!!!
+network *load_network_ca(char *cfg, char *weights, int clear); 
+network *load_network_ca(char *cfg, char *weights, int clear) {
+    network *net;
+    net  = parse_network_cfg_ca(cfg);
+    if (net == NULL) {
+        return NULL;
+    }
+    if(weights && weights[0] != 0){
+        //LOGD("load weights: net:%p",net);
+        load_weights_ca(net, weights);
+        //LOGD("after load weights: net:%p",net);
+    }
+    if(clear) (*net->seen) = 0;
+    //LOGD("return load network,%p", net);
+    return net;
+}
+
+network *load_network_ca_shadownet(char *cfg, char *weights, int clear); 
+network *load_network_ca_shadownet(char *cfg, char *weights, int clear) {
+    network *net;
+    net  = parse_network_cfg_ca_shadownet(cfg);
+    if (net == NULL) {
+        return NULL;
+    }
+    if(weights && weights[0] != 0){
+        //LOGD("load weights: net:%p",net);
+        load_weights_ca(net, weights);
+        //LOGD("after load weights: net:%p",net);
+    }
+    if(clear) (*net->seen) = 0;
+    //LOGD("return load network,%p", net);
+    return net;
+}
+
+network *load_network(char *cfg, char *weights, int clear)
+{
+    //network *net = parse_network_cfg(cfg);
+    network *net = parse_network_cfg_wrapper(cfg);
+    if(weights && weights[0] != 0){
+        load_weights(net, weights);
+    }
+    if(clear) (*net->seen) = 0;
+    return net;
+}
+
+void set_batch_network(network *net, int b)
+{
+    net->batch = b;
+    int i;
+    for(i = 0; i < net->n; ++i){
+        net->layers[i].batch = b;
+    }
+}
+
+char *get_layer_string(LAYER_TYPE a)
+{
+    switch(a){
+        case ACTIVE:
+            return "activation";
+        case AVGPOOL:
+            return "avgpool";
+        case SOFTMAX:
+            return "softmax";
+        case DROPOUT:
+            return "dropout";
+        case BATCHNORM:
+            return "batchnorm";
+        case ADD_MASK:
+            return "add_mask";
+        case LINEAR_TRANSFORM:
+            return "linear_transform";
+        case SHUFFLE_CHANNEL:
+            return "shuffle_channel";
+        default:
+            break;
+    }
+    return "none";
+}
+
+network *make_network(int n)
+{
+    network *net = calloc(1, sizeof(network));
+    if (net == NULL) {
+        LOGD("net calloc fail!\n");
+        return NULL;
+    }
+    net->n = n;
+    net->layers = calloc(net->n, sizeof(layer));
+    net->seen = calloc(1, sizeof(size_t));
+    net->t    = calloc(1, sizeof(int));
+    //LOGD("net:%p,net->seen:%p,net->t:%p\n", net, net->seen, net->t);
+    return net;
+}
+
+void forward_network(network *netp)
+{
+    network net = *netp;
+    int i;
+    for(i = 0; i < net.n; ++i){
+        net.index = i;
+        layer l = net.layers[i];
+        l.forward(l, net);
+        net.input = l.output;
+    }
+}
+
+int get_predicted_class_network(network *net)
+{
+    return max_index(net->output, net->outputs);
+}
+
+void top_predictions(network *net, int k, int *index)
+{
+    top_k(net->output, net->outputs, k, index);
+}
+
+float *network_predict_ca(network *net, float *input) {
+    //LOGD("%s net:%p",__func__, net);
+    network_predict_ca_cmd(net->ta_netid, input,net->inputs * sizeof(float), net->output, net->outputs*sizeof(float));
+    return net->output;
+}
+
+float *network_predict(network *net, float *input)
+{
+    network orig = *net;
+    net->input = input;
+    forward_network(net);
+    float *out = net->output;
+    *net = orig;
+    return out;
+}
+
+int network_width(network *net){return net->w;}
+int network_height(network *net){return net->h;}
+
+layer get_network_output_layer(network *net)
+{
+    return net->layers[net->n-1];
+}
+
+void free_network(network *net)
+{
+    int i;
+    for(i = 0; i < net->n; ++i){
+        free_layer(net->layers[i]);
+    }
+    free(net->layers);
+    if(net->input) free(net->input);
+    free(net);
+}
+
+
+layer network_output_layer(network *net)
+{
+    return net->layers[net->n - 1];
+}
+
+int network_inputs(network *net)
+{
+    return net->layers[0].inputs;
+}
+
+int network_outputs(network *net)
+{
+    return network_output_layer(net).outputs;
+}
+
+float *network_output(network *net)
+{
+    return network_output_layer(net).output;
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/network.h b/third_party/optee_delegate/darknet_ca/src/network.h
new file mode 100644
index 0000000..494e2c1
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/network.h
@@ -0,0 +1,14 @@
+// Oh boy, why am I about to do this....
+#ifndef NETWORK_H
+#define NETWORK_H
+#include "darknet.h"
+
+#include "layer.h"
+
+
+char *get_layer_string(LAYER_TYPE a);
+
+network *make_network(int n);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/option_list.c b/third_party/optee_delegate/darknet_ca/src/option_list.c
new file mode 100644
index 0000000..f935af3
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/option_list.c
@@ -0,0 +1,123 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "option_list.h"
+#include "utils.h"
+
+list *read_data_cfg(char *filename)
+{
+    FILE *file = fopen(filename, "r");
+    if(file == 0) file_error(filename);
+    char *line;
+    int nu = 0;
+    list *options = make_list();
+    while((line=fgetl(file)) != 0){
+        ++ nu;
+        strip(line);
+        switch(line[0]){
+            case '\0':
+            case '#':
+            case ';':
+                free(line);
+                break;
+            default:
+                if(!read_option(line, options)){
+                    fprintf(stderr, "Config file error line %d, could parse: %s\n", nu, line);
+                    free(line);
+                }
+                break;
+        }
+    }
+    fclose(file);
+    return options;
+}
+
+int read_option(char *s, list *options)
+{
+    size_t i;
+    size_t len = strlen(s);
+    char *val = 0;
+    for(i = 0; i < len; ++i){
+        if(s[i] == '='){
+            s[i] = '\0';
+            val = s+i+1;
+            break;
+        }
+    }
+    if(i == len-1) return 0;
+    char *key = s;
+    option_insert(options, key, val);
+    return 1;
+}
+
+void option_insert(list *l, char *key, char *val)
+{
+    kvp *p = malloc(sizeof(kvp));
+    p->key = key;
+    p->val = val;
+    p->used = 0;
+    list_insert(l, p);
+}
+
+void option_unused(list *l)
+{
+    node *n = l->front;
+    while(n){
+        kvp *p = (kvp *)n->val;
+        if(!p->used){
+            fprintf(stderr, "Unused field: '%s = %s'\n", p->key, p->val);
+        }
+        n = n->next;
+    }
+}
+
+char *option_find(list *l, char *key)
+{
+    node *n = l->front;
+    while(n){
+        kvp *p = (kvp *)n->val;
+        if(strcmp(p->key, key) == 0){
+            p->used = 1;
+            return p->val;
+        }
+        n = n->next;
+    }
+    return 0;
+}
+char *option_find_str(list *l, char *key, char *def)
+{
+    char *v = option_find(l, key);
+    if(v) return v;
+    if(def) fprintf(stderr, "%s: Using default '%s'\n", key, def);
+    return def;
+}
+
+int option_find_int(list *l, char *key, int def)
+{
+    char *v = option_find(l, key);
+    if(v) return atoi(v);
+    fprintf(stderr, "%s: Using default '%d'\n", key, def);
+    return def;
+}
+
+int option_find_int_quiet(list *l, char *key, int def)
+{
+    char *v = option_find(l, key);
+    if(v) return atoi(v);
+    return def;
+}
+
+float option_find_float_quiet(list *l, char *key, float def)
+{
+    char *v = option_find(l, key);
+    if(v) return atof(v);
+    return def;
+}
+
+float option_find_float(list *l, char *key, float def)
+{
+    char *v = option_find(l, key);
+    if(v) return atof(v);
+    fprintf(stderr, "%s: Using default '%lf'\n", key, def);
+    return def;
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/option_list.h b/third_party/optee_delegate/darknet_ca/src/option_list.h
new file mode 100644
index 0000000..844bd87
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/option_list.h
@@ -0,0 +1,19 @@
+#ifndef OPTION_LIST_H
+#define OPTION_LIST_H
+#include "list.h"
+
+typedef struct{
+    char *key;
+    char *val;
+    int used;
+} kvp;
+
+
+int read_option(char *s, list *options);
+void option_insert(list *l, char *key, char *val);
+char *option_find(list *l, char *key);
+float option_find_float(list *l, char *key, float def);
+float option_find_float_quiet(list *l, char *key, float def);
+void option_unused(list *l);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/parser.c b/third_party/optee_delegate/darknet_ca/src/parser.c
new file mode 100644
index 0000000..d102dfb
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/parser.c
@@ -0,0 +1,681 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include "activation_layer.h"
+#include "activations.h"
+#include "avgpool_layer.h"
+#include "batchnorm_layer.h"
+#include "blas.h"
+#include "dropout_layer.h"
+#include "list.h"
+#include "option_list.h"
+#include "parser.h"
+#include "softmax_layer.h"
+#include "add_mask_layer.h"
+#include "linear_transform_layer.h"
+#include "shuffle_channel_layer.h"
+#include "utils.h"
+#include "ca_cmds.h"
+
+typedef struct{
+    char *type;
+    list *options;
+}section;
+
+
+list *read_cfg(char *filename);
+
+LAYER_TYPE string_to_layer_type(char * type)
+{
+
+    if (strcmp(type, "[activation]")==0) return ACTIVE;
+    if (strcmp(type, "[net]")==0
+            || strcmp(type, "[network]")==0) return NETWORK;
+    if (strcmp(type, "[avg]")==0
+            || strcmp(type, "[avgpool]")==0) return AVGPOOL;
+    if (strcmp(type, "[dropout]")==0) return DROPOUT;
+    if (strcmp(type, "[batchnorm]")==0) return BATCHNORM;
+    if (strcmp(type, "[soft]")==0
+            || strcmp(type, "[softmax]")==0) return SOFTMAX;
+    if (strcmp(type, "[add_mask]")==0) return ADD_MASK;
+    if (strcmp(type, "[linear_transform]")==0) return LINEAR_TRANSFORM;
+    if (strcmp(type, "[shuffle_channel]")==0) return SHUFFLE_CHANNEL;
+    return BLANK;
+}
+
+void free_section(section *s)
+{
+    free(s->type);
+    node *n = s->options->front;
+    while(n){
+        kvp *pair = (kvp *)n->val;
+        free(pair->key);
+        free(pair);
+        node *next = n->next;
+        free(n);
+        n = next;
+    }
+    free(s->options);
+    free(s);
+}
+
+typedef struct size_params{
+    int batch;
+    int inputs;
+    int h;
+    int w;
+    int c;
+    int index;
+    network *net;
+} size_params;
+
+layer parse_add_mask(list *options, size_params params)
+{
+    layer l = make_add_mask_layer(params.batch, params.h, params.w, params.c);
+    return l;
+}
+
+layer parse_linear_transform(list *options, size_params params)
+{
+    int units = option_find_int(options, "units",1);
+    layer l = make_linear_transform_layer(params.batch, params.h, params.w, params.c, units);
+    return l;
+}
+
+layer parse_shuffle_channel(list *options, size_params params)
+{
+    layer l = make_shuffle_channel_layer(params.batch, params.h, params.w, params.c);
+    return l;
+}
+
+layer parse_softmax(list *options, size_params params)
+{
+    int groups = option_find_int_quiet(options, "groups",1);
+    layer l = make_softmax_layer(params.batch, params.inputs, groups);
+    l.temperature = option_find_float_quiet(options, "temperature", 1);
+    l.w = params.w;
+    l.h = params.h;
+    l.c = params.c;
+    l.spatial = option_find_float_quiet(options, "spatial", 0);
+    l.noloss =  option_find_int_quiet(options, "noloss", 0);
+    return l;
+}
+
+avgpool_layer parse_avgpool(list *options, size_params params)
+{
+    int batch,w,h,c;
+    w = params.w;
+    h = params.h;
+    c = params.c;
+    batch=params.batch;
+    if(!(h && w && c)) LOGD("Layer before avgpool layer must output image.");
+
+    int use_nhwc = option_find_int(options, "nhwc", 0);
+    avgpool_layer layer = make_avgpool_layer(batch,w,h,c);
+    layer.nhwc = use_nhwc;
+    return layer;
+}
+
+dropout_layer parse_dropout(list *options, size_params params)
+{
+    float probability = option_find_float(options, "probability", .5);
+    dropout_layer layer = make_dropout_layer(params.batch, params.inputs, probability);
+    layer.out_w = params.w;
+    layer.out_h = params.h;
+    layer.out_c = params.c;
+    return layer;
+}
+
+layer parse_batchnorm(list *options, size_params params)
+{
+    int load_bias = option_find_int(options, "bn_bias", 0);
+    int use_nhwc = option_find_int(options, "nhwc", 0);
+    layer l = make_batchnorm_layer(params.batch, params.w, params.h, params.c);
+    l.bn_bias = load_bias;
+    l.nhwc = use_nhwc;
+    return l;
+}
+
+layer parse_activation(list *options, size_params params)
+{
+    char *activation_s = option_find_str(options, "activation", "linear");
+    ACTIVATION activation = get_activation(activation_s);
+
+    layer l = make_activation_layer(params.batch, params.inputs, activation);
+
+    l.h = l.out_h = params.h;
+    l.w = l.out_w = params.w;
+    l.c = l.out_c = params.c;
+
+    return l;
+}
+
+void parse_net_options(list *options, network *net)
+{
+    net->batch = option_find_int(options, "batch",1);
+    net->h = option_find_int_quiet(options, "height",0);
+    net->w = option_find_int_quiet(options, "width",0);
+    net->c = option_find_int_quiet(options, "channels",0);
+    net->inputs = option_find_int_quiet(options, "inputs", net->h * net->w * net->c);
+    if(!net->inputs && !(net->h && net->w && net->c)) LOGD("No input parameters supplied");
+
+}
+
+int is_network(section *s)
+{
+    return (strcmp(s->type, "[net]")==0
+            || strcmp(s->type, "[network]")==0);
+}
+
+network *parse_network_cfg_from_buf(char *cfg_buf);
+network *parse_network_cfg_ca(char *filename)
+{
+    char *cfg_buf = read_file(filename);
+    int ta_netid = 0;
+    network *net;
+
+    if (!cfg_buf){
+        LOGD("Error! cfg_buf is null!");
+        return NULL;
+    }
+    ta_netid = parse_network_cfg_ca_cmd(cfg_buf);
+    if (ta_netid < 0)  // ca_netid LOGD!
+        return NULL;
+
+    // ta_netid records netid of the net created in TA with `filename`
+    // create mirror net in ca
+    net = parse_network_cfg_from_buf(cfg_buf);
+    net->ta_netid = ta_netid;
+    //LOGD("%s: before return ,net:%p!",__func__, net);
+
+    return net;
+}
+
+network *parse_network_cfg_ca_shadownet(char *filename);
+network *parse_network_cfg_ca_shadownet(char *filename);
+{
+    char *cfg_buf = read_file(filename);
+    int ta_netid = 0;
+    network *net;
+
+    if (!cfg_buf){
+        LOGD("Error! cfg_buf is null!");
+        return NULL;
+    }
+    ta_netid = parse_network_cfg_ca_cmd(cfg_buf);
+    if (ta_netid < 0)  // ca_netid LOGD!
+        return NULL;
+
+    // ta_netid records netid of the net created in TA with `filename`
+    // create mirror net in ca
+    net = parse_network_cfg_from_buf(cfg_buf);
+    net->ta_netid = ta_netid;
+    //LOGD("%s: before return ,net:%p!",__func__, net);
+
+    return net;
+}
+
+network *parse_network_cfg_from_buf(char *cfg_buf)
+{
+    //char *cfg_buf = read_file(filename);
+    //LOGD("%s %s\n",__func__, cfg_buf);
+    list *sections = read_cfg_from_buf(cfg_buf);
+    node *n = sections->front;
+    if(!n) LOGD("Config file has no sections");
+    network *net = make_network(sections->size - 1);
+    size_params params;
+
+    section *s = (section *)n->val;
+    list *options = s->options;
+    if(!is_network(s)) LOGD("First section must be [net] or [network]");
+    parse_net_options(options, net);
+
+    params.h = net->h;
+    params.w = net->w;
+    params.c = net->c;
+    params.inputs = net->inputs;
+    params.batch = net->batch;
+    params.net = net;
+
+    n = n->next;
+    int count = 0;
+    free_section(s);
+    LOGD("layer     filters    size              input                output\n");
+    while(n){
+        params.index = count;
+        LOGD("%5d ", count);
+        s = (section *)n->val;
+        options = s->options;
+        layer l = {0};
+        LAYER_TYPE lt = string_to_layer_type(s->type);
+        if(lt == ADD_MASK){
+            l = parse_add_mask(options, params);
+        }else if(lt == LINEAR_TRANSFORM){
+            l = parse_linear_transform(options, params);
+        }else if(lt == SHUFFLE_CHANNEL){
+            l = parse_shuffle_channel(options, params);
+        }else if(lt == ACTIVE){
+            l = parse_activation(options, params);
+        }else if(lt == SOFTMAX){
+            l = parse_softmax(options, params);
+        }else if(lt == BATCHNORM){
+            l = parse_batchnorm(options, params);
+        }else if(lt == AVGPOOL){
+            l = parse_avgpool(options, params);
+        }else if(lt == DROPOUT){
+            l = parse_dropout(options, params);
+            l.output = net->layers[count-1].output;
+        }else{
+            LOGD("Type not recognized: %s\n", s->type);
+        }
+        option_unused(options);
+        net->layers[count] = l;
+        free_section(s);
+        n = n->next;
+        ++count;
+        if(n){
+            params.h = l.out_h;
+            params.w = l.out_w;
+            params.c = l.out_c;
+            params.inputs = l.outputs;
+        }
+        //LOGD("net:%p", net);
+    }
+    free_list(sections);
+    layer out = get_network_output_layer(net);
+    net->outputs = out.outputs;
+    net->output = out.output;
+    net->input = calloc(net->inputs*net->batch, sizeof(float));
+    //LOGD("before return parse net:%p", net);
+    return net;
+}
+
+network *parse_network_cfg(char *filename)
+{
+    list *sections = read_cfg(filename);
+    node *n = sections->front;
+    if(!n) LOGD("Config file has no sections");
+    network *net = make_network(sections->size - 1);
+    size_params params;
+
+    section *s = (section *)n->val;
+    list *options = s->options;
+    if(!is_network(s)) LOGD("First section must be [net] or [network]");
+    parse_net_options(options, net);
+
+    params.h = net->h;
+    params.w = net->w;
+    params.c = net->c;
+    params.inputs = net->inputs;
+    params.batch = net->batch;
+    params.net = net;
+
+    n = n->next;
+    int count = 0;
+    free_section(s);
+    LOGD("layer     filters    size              input                output\n");
+    while(n){
+        params.index = count;
+        LOGD("%5d ", count);
+        s = (section *)n->val;
+        options = s->options;
+        layer l = {0};
+        LAYER_TYPE lt = string_to_layer_type(s->type);
+        if(lt == ADD_MASK){
+            l = parse_add_mask(options, params);
+        }else if(lt == LINEAR_TRANSFORM){
+            l = parse_linear_transform(options, params);
+        }else if(lt == SHUFFLE_CHANNEL){
+            l = parse_shuffle_channel(options, params);
+        }else if(lt == ACTIVE){
+            l = parse_activation(options, params);
+        }else if(lt == SOFTMAX){
+            l = parse_softmax(options, params);
+        }else if(lt == BATCHNORM){
+            l = parse_batchnorm(options, params);
+        }else if(lt == AVGPOOL){
+            l = parse_avgpool(options, params);
+        }else if(lt == DROPOUT){
+            l = parse_dropout(options, params);
+            l.output = net->layers[count-1].output;
+        }else{
+            LOGD("Type not recognized: %s\n", s->type);
+        }
+        option_unused(options);
+        net->layers[count] = l;
+        free_section(s);
+        n = n->next;
+        ++count;
+        if(n){
+            params.h = l.out_h;
+            params.w = l.out_w;
+            params.c = l.out_c;
+            params.inputs = l.outputs;
+        }
+    }
+    free_list(sections);
+    layer out = get_network_output_layer(net);
+    net->outputs = out.outputs;
+    net->output = out.output;
+    net->input = calloc(net->inputs*net->batch, sizeof(float));
+    return net;
+}
+
+list *read_cfg_from_buf(char * cfg_buf)
+{
+    char *line, *cfg_item;
+    char delim[] = "\n";
+    int nu = 0;
+    list *options = make_list();
+    section *current = 0;
+    cfg_item = strtok(cfg_buf, delim);
+    while(cfg_item != NULL) {
+        line = malloc(strlen(cfg_item) + 1);
+        strcpy(line, cfg_item);
+        printf("line:%s\n",line);
+        ++ nu;
+        strip(line);
+        switch(line[0]){
+            case '[':
+                current = malloc(sizeof(section));
+                list_insert(options, current);
+                current->options = make_list();
+                current->type = line;
+                break;
+            case '\0':
+            case '#':
+            case ';':
+                free(line);
+                break;
+            default:
+                if(!read_option(line, current->options)){
+                    LOGD("Config file LOGD line %d, could parse: %s\n", nu, line);
+                    free(line);
+                }
+                break;
+        }
+        cfg_item = strtok(NULL, delim);
+    }
+    return options;
+}
+
+list *read_cfg(char *filename)
+{
+    FILE *file = fopen(filename, "r");
+    if(file == 0) file_LOGD(filename);
+    char *line;
+    int nu = 0;
+    list *options = make_list();
+    section *current = 0;
+    while((line=fgetl(file)) != 0){
+        ++ nu;
+        strip(line);
+        switch(line[0]){
+            case '[':
+                current = malloc(sizeof(section));
+                list_insert(options, current);
+                current->options = make_list();
+                current->type = line;
+                break;
+            case '\0':
+            case '#':
+            case ';':
+                free(line);
+                break;
+            default:
+                if(!read_option(line, current->options)){
+                    LOGD("Config file LOGD line %d, could parse: %s\n", nu, line);
+                    free(line);
+                }
+                break;
+        }
+    }
+    fclose(file);
+    return options;
+}
+
+void save_add_mask_weights(layer l, FILE *fp)
+{
+    fwrite(l.rscalar, sizeof(float), 1, fp);
+    fwrite(l.weights, sizeof(float), l.outputs, fp);
+}
+
+void save_linear_transform_weights(layer l, FILE *fp)
+{
+    fwrite(l.obfweights, sizeof(int), l.units*2, fp);
+    fwrite(l.rbias, sizeof(float), l.units, fp);
+}
+
+void save_shuffle_channel_weights(layer l, FILE *fp)
+{
+    fwrite(l.obfweights, sizeof(int), l.units, fp);
+    fwrite(l.rbias, sizeof(float), l.units, fp);
+}
+
+void save_batchnorm_weights(layer l, FILE *fp)
+{
+    fwrite(l.scales, sizeof(float), l.c, fp);
+    if (l.bn_bias== 1) {
+        fwrite(l.biases, sizeof(float), l.c, fp);
+    }
+    fwrite(l.rolling_mean, sizeof(float), l.c, fp);
+    fwrite(l.rolling_variance, sizeof(float), l.c, fp);
+}
+
+void save_weights_upto(network *net, char *filename, int cutoff)
+{
+    LOGD("Saving weights to %s\n", filename);
+    FILE *fp = fopen(filename, "wb");
+    if(!fp) file_LOGD(filename);
+
+    int major = 0;
+    int minor = 2;
+    int revision = 0;
+    fwrite(&major, sizeof(int), 1, fp);
+    fwrite(&minor, sizeof(int), 1, fp);
+    fwrite(&revision, sizeof(int), 1, fp);
+    fwrite(net->seen, sizeof(size_t), 1, fp);
+
+    int i;
+    for(i = 0; i < net->n && i < cutoff; ++i){
+        layer l = net->layers[i];
+        if(l.type == BATCHNORM){
+            save_batchnorm_weights(l, fp);
+        } if(l.type == ADD_MASK){
+            save_add_mask_weights(l, fp);
+        } if(l.type == LINEAR_TRANSFORM){
+            save_linear_transform_weights(l, fp);
+        } if(l.type == SHUFFLE_CHANNEL){
+            save_shuffle_channel_weights(l, fp);
+        }
+    }
+    fclose(fp);
+}
+void save_weights(network *net, char *filename)
+{
+    save_weights_upto(net, filename, net->n);
+}
+
+void load_add_mask_weights_ca(int id,int ta_netid,  layer l, FILE *fp)
+{
+    //LOGD("load add mask weights ca");
+    fread(l.weights, sizeof(float), l.outputs, fp);
+    load_weights_ca_cmd(ta_netid, id, l.weights, 1, l.outputs * sizeof(float)); 
+    DUMPW8("add_mask w",l.outputs*4, l.weights);
+    fread(l.rscalar, sizeof(float), 1, fp);
+    load_weights_ca_cmd(ta_netid, id, l.rscalar, 2, 1 * sizeof(float));
+    DUMPW8("add_mask r",4, l.rscalar);
+}
+
+void load_add_mask_weights(layer l, FILE *fp)
+{
+    fread(l.weights, sizeof(float), l.outputs, fp);
+    DUMPW8("add_mask w",l.outputs*4, l.weights);
+    fread(l.rscalar, sizeof(float), 1, fp);
+    DUMPW8("add_mask r",4, l.rscalar);
+}
+
+void load_linear_transform_weights_ca(int id,int ta_netid,  layer l, FILE *fp)
+{
+    fread(l.obfweights, sizeof(int), l.units*2, fp);
+    load_weights_ca_cmd(ta_netid, id, l.obfweights, 1, l.units*2* sizeof(int)); 
+    DUMPW8("linear_transform obfw",l.units*8, l.obfweights);
+    fread(l.rbias, sizeof(float), l.units, fp);
+    load_weights_ca_cmd(ta_netid, id, l.rbias, 2, l.units*sizeof(float)); 
+    DUMPW8("linear_transform rbias",l.units*4,l.rbias);
+}
+
+void load_linear_transform_weights(layer l, FILE *fp)
+{
+    fread(l.obfweights, sizeof(int), l.units*2, fp);
+    DUMPW8("linear_transform obfw",l.units*8, l.obfweights);
+    fread(l.rbias, sizeof(float), l.units, fp);
+    DUMPW8("linear_transform rbias",l.units*4,l.rbias);
+}
+
+void load_shuffle_channel_weights_ca(int id,int ta_netid,  layer l, FILE *fp)
+{
+    fread(l.obfweights, sizeof(int), l.c, fp);
+    load_weights_ca_cmd(ta_netid, id, l.obfweights, 1, l.c*sizeof(int)); 
+    DUMPW8("shuffle_channel obfw",l.c*4, l.obfweights);
+    fread(l.rbias, sizeof(float), l.c, fp);
+    load_weights_ca_cmd(ta_netid, id, l.rbias, 2, l.c*sizeof(float)); 
+    DUMPW8("shuffle_channel rbias",l.c*4, l.rbias);
+}
+
+void load_shuffle_channel_weights(layer l, FILE *fp)
+{
+    fread(l.obfweights, sizeof(int), l.c, fp);
+    DUMPW8("shuffle_channel obfw",l.c*4, l.obfweights);
+    fread(l.rbias, sizeof(float), l.c, fp);
+    DUMPW8("shuffle_channel rbias",l.c*4, l.rbias);
+}
+
+void load_batchnorm_weights_ca(int id,int ta_netid,  layer l, FILE *fp)
+{
+    fread(l.scales, sizeof(float), l.c, fp);
+    load_weights_ca_cmd(ta_netid, id, l.scales, 1, l.c*sizeof(float)); 
+    DUMPW4F("bn scales",l.c, l.scales);
+    if (l.bn_bias == 1) {
+        printf("bn_bias = 1,load biases\n");
+        fread(l.biases, sizeof(float), l.c, fp);
+        load_weights_ca_cmd(ta_netid, id, l.biases, 2, l.c*sizeof(float)); 
+        DUMPW4F("bn biases",l.c, l.biases);
+    }
+    fread(l.rolling_mean, sizeof(float), l.c, fp);
+    load_weights_ca_cmd(ta_netid, id, l.rolling_mean, 3, l.c*sizeof(float)); 
+    DUMPW4F("bn mean",l.c, l.rolling_mean);
+    fread(l.rolling_variance, sizeof(float), l.c, fp);
+    load_weights_ca_cmd(ta_netid, id, l.rolling_variance, 4, l.c*sizeof(float)); 
+    DUMPW4F("bn variance",l.c, l.rolling_variance);
+}
+
+void load_batchnorm_weights(layer l, FILE *fp)
+{
+    fread(l.scales, sizeof(float), l.c, fp);
+    DUMPW4F("bn scales",l.c, l.scales);
+    if (l.bn_bias == 1) {
+        printf("bn_bias = 1,load biases\n");
+        fread(l.biases, sizeof(float), l.c, fp);
+        DUMPW4F("bn biases",l.c, l.biases);
+    }
+    fread(l.rolling_mean, sizeof(float), l.c, fp);
+    DUMPW4F("bn mean",l.c, l.rolling_mean);
+    fread(l.rolling_variance, sizeof(float), l.c, fp);
+    DUMPW4F("bn variance",l.c, l.rolling_variance);
+}
+
+void load_weights_upto(network *net, char *filename, int start, int cutoff)
+{
+    //LOGD("Loading weights from %s...", filename);
+    fflush(stdout);
+    FILE *fp = fopen(filename, "rb");
+    if(!fp) file_LOGD(filename);
+
+    int major;
+    int minor;
+    int revision;
+    fread(&major, sizeof(int), 1, fp);
+    fread(&minor, sizeof(int), 1, fp);
+    fread(&revision, sizeof(int), 1, fp);
+    if ((major*10 + minor) >= 2 && major < 1000 && minor < 1000){
+        fread(net->seen, sizeof(size_t), 1, fp);
+    } else {
+        int iseen = 0;
+        fread(&iseen, sizeof(int), 1, fp);
+        *net->seen = iseen;
+    }
+
+    int i;
+    for(i = start; i < net->n && i < cutoff; ++i){
+        layer l = net->layers[i];
+        if(l.type == ADD_MASK){
+            load_add_mask_weights(l, fp);
+        }
+        if(l.type == LINEAR_TRANSFORM){
+            load_linear_transform_weights(l, fp);
+        }
+        if(l.type == SHUFFLE_CHANNEL){
+            load_shuffle_channel_weights(l, fp);
+        }
+        if(l.type == BATCHNORM){
+            load_batchnorm_weights(l, fp);
+        }
+    }
+    LOGD("Done!\n");
+    fclose(fp);
+}
+
+void load_weights_ca(network *net, char *filename)
+{
+    //LOGD("Loading weights from %s ", filename);
+    FILE *fp = fopen(filename, "rb");
+    if(!fp) file_error(filename);
+
+    int major;
+    int minor;
+    int revision;
+    //LOGD("Start reading, major:%d, net:%p",major, net);
+    fread(&major, sizeof(int), 1, fp);
+    fread(&minor, sizeof(int), 1, fp);
+    fread(&revision, sizeof(int), 1, fp);
+    //LOGD("read a few bytes, major:%d, minor:%d,:net:%p",major,minor, net);
+    if ((major*10 + minor) >= 2 && major < 1000 && minor < 1000){
+        //LOGD("safe flag");
+        //LOGD("read seen :net:%p ", net );
+        //LOGD("read seen :%p ", net->seen);
+        fread(net->seen, sizeof(size_t), 1, fp);
+    } else {
+        //LOGD("should not be here!read seen :%p ", net->seen);
+        int iseen = 0;
+        fread(&iseen, sizeof(int), 1, fp);
+        *net->seen = iseen;
+    }
+
+    //LOGD("before load layer weights");
+    int i;
+    for(i = 0; i < net->n ; ++i){
+        layer l = net->layers[i];
+        if(l.type == ADD_MASK){
+            load_add_mask_weights_ca(i, net->ta_netid, l, fp);
+        }
+        if(l.type == LINEAR_TRANSFORM){
+            load_linear_transform_weights_ca(i, net->ta_netid, l, fp);
+        }
+        if(l.type == SHUFFLE_CHANNEL){
+            load_shuffle_channel_weights_ca(i, net->ta_netid, l, fp);
+        }
+        if(l.type == BATCHNORM){
+            load_batchnorm_weights_ca(i, net->ta_netid, l, fp);
+        }
+    }
+    LOGD("Done! net: %p\n",net);
+    fclose(fp);
+}
+
+void load_weights(network *net, char *filename)
+{
+    load_weights_upto(net, filename, 0, net->n);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/parser.h b/third_party/optee_delegate/darknet_ca/src/parser.h
new file mode 100644
index 0000000..94282f7
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/parser.h
@@ -0,0 +1,11 @@
+#ifndef PARSER_H
+#define PARSER_H
+#include "darknet.h"
+#include "network.h"
+
+void save_network(network net, char *filename);
+void save_weights_double(network net, char *filename);
+list *read_cfg_from_buf(char * cfg_buf);
+network *parse_network_cfg_wrapper(char *filename);
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.c b/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.c
new file mode 100644
index 0000000..f23e8bf
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.c
@@ -0,0 +1,60 @@
+#include "shuffle_channel_layer.h"
+#include "utils.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+layer make_shuffle_channel_layer(int batch, int h, int w, int c)
+{
+    layer l = {0};
+    l.type = SHUFFLE_CHANNEL;
+
+    l.batch = batch;
+    l.h = h;
+    l.w = w;
+    l.c = c;
+    l.inputs = l.h * l.w * l.c;
+
+    l.out_h = h;
+    l.out_w = w;
+    l.out_c = c;
+    l.outputs = l.h * l.w * l.c;
+
+    l.output = calloc(batch*l.outputs, sizeof(float));
+    l.obfweights = calloc(l.c, sizeof(int));
+    l.rbias = calloc(l.c, sizeof(float));
+
+    l.forward = forward_shuffle_channel_layer;
+    LOGD("Shuffle_Channel Layer: %d inputs\n", l.inputs);
+    return l;
+}
+
+void forward_shuffle_channel_layer(layer l, network net)
+{
+    fill_cpu(l.outputs*l.batch, 0, l.output, 1);
+    int B = l.batch;
+    int H = l.h;
+    int W = l.w;
+    int N = l.c;
+
+    int b, h, w, n;
+    int idx_from;
+    float scalar;
+    for (b = 0; b < B; ++b){
+        for (h = 0; h < H; ++h) {
+            for (w = 0; w < W; ++w) {
+                for (n = 0; n < N; ++n) {
+                    idx_from = l.obfweights[n];
+                    scalar = l.rbias[n];
+
+                    l.output[(b * H * W * N) + (h * W * N) + (w * N) + n] = 
+                      net.input[(b * H * W * N) + (h * W * N) + (w * N) + idx_from] * scalar;
+                }
+            }
+        }
+    }
+    DUMPW8("shuffle channel output bytes:",l.outputs, l.output);
+    DUMPW4F("shuffle channel output float:",l.outputs, l.output);
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.h b/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.h
new file mode 100644
index 0000000..b78e5be
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/shuffle_channel_layer.h
@@ -0,0 +1,12 @@
+#ifndef SHUFFLE_CHANNEL_LAYER_H
+#define SHUFFLE_CHANNEL_LAYER_H
+
+#include "layer.h"
+#include "network.h"
+
+layer make_shuffle_channel_layer(int batch, int h, int w, int c);
+
+void forward_shuffle_channel_layer(layer l, network net);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/src/softmax_layer.c b/third_party/optee_delegate/darknet_ca/src/softmax_layer.c
new file mode 100644
index 0000000..18ce3ca
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/softmax_layer.c
@@ -0,0 +1,30 @@
+#include "softmax_layer.h"
+#include "blas.h"
+
+#include <float.h>
+#include <math.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+
+softmax_layer make_softmax_layer(int batch, int inputs, int groups)
+{
+    assert(inputs%groups == 0);
+    fprintf(stderr, "softmax                                        %4d\n",  inputs);
+    softmax_layer l = {0};
+    l.type = SOFTMAX;
+    l.batch = batch;
+    l.groups = groups;
+    l.inputs = inputs;
+    l.outputs = inputs;
+    l.output = calloc(inputs*batch, sizeof(float));
+
+    l.forward = forward_softmax_layer;
+    return l;
+}
+
+void forward_softmax_layer(const softmax_layer l, network net)
+{
+    softmax_cpu(net.input, l.inputs/l.groups, l.batch, l.inputs, l.groups, l.inputs/l.groups, 1, l.temperature, l.output);
+
+}
diff --git a/third_party/optee_delegate/darknet_ca/src/softmax_layer.h b/third_party/optee_delegate/darknet_ca/src/softmax_layer.h
new file mode 100644
index 0000000..2e3ffe0
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/softmax_layer.h
@@ -0,0 +1,19 @@
+#ifndef SOFTMAX_LAYER_H
+#define SOFTMAX_LAYER_H
+#include "layer.h"
+#include "network.h"
+
+typedef layer softmax_layer;
+
+void softmax_array(float *input, int n, float temp, float *output);
+softmax_layer make_softmax_layer(int batch, int inputs, int groups);
+void forward_softmax_layer(const softmax_layer l, network net);
+void backward_softmax_layer(const softmax_layer l, network net);
+
+#ifdef GPU
+void pull_softmax_layer_output(const softmax_layer l);
+void forward_softmax_layer_gpu(const softmax_layer l, network net);
+void backward_softmax_layer_gpu(const softmax_layer l, network net);
+#endif
+
+#endif
diff --git a/third_party/optee_delegate/darknet_ca/src/tags b/third_party/optee_delegate/darknet_ca/src/tags
new file mode 100644
index 0000000..5a310a6
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/tags
@@ -0,0 +1,215 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+ACTIVATIONS_H	activations.h	2;"	d
+ACTIVATION_LAYER_H	activation_layer.h	2;"	d
+ADD_MASK_LAYER_H	add_mask_layer.h	2;"	d
+AVGPOOL_LAYER_H	avgpool_layer.h	2;"	d
+BATCHNORM_LAYER_H	batchnorm_layer.h	2;"	d
+BLAS_H	blas.h	2;"	d
+CMD_LOAD_WEIGHTS	ca_cmds.h	15;"	d
+CMD_NETWORK_PREDICT	ca_cmds.h	16;"	d
+CMD_PARSE_NETWORK_CFG	ca_cmds.h	14;"	d
+CMD_TEST	ca_cmds.h	11;"	d
+DEBUG_WEIGHTS	utils.h	8;"	d
+DROPOUT_LAYER_H	dropout_layer.h	2;"	d
+DUMPW4	utils.h	35;"	d
+DUMPW4	utils.h	45;"	d
+DUMPW4F	utils.h	12;"	d
+DUMPW4F	utils.h	42;"	d
+DUMPW4I	utils.h	18;"	d
+DUMPW4I	utils.h	43;"	d
+DUMPW8	utils.h	25;"	d
+DUMPW8	utils.h	44;"	d
+LINEAR_TRANSFORM_LAYER_H	linear_transform_layer.h	2;"	d
+LIST_H	list.h	2;"	d
+MODEL_SAFE_BASE	ca_cmds.h	13;"	d
+NETWORK_H	network.h	3;"	d
+OPTION_LIST_H	option_list.h	2;"	d
+PARSER_H	parser.h	2;"	d
+SHUFFLE_CHANNEL_LAYER_H	shuffle_channel_layer.h	2;"	d
+SOFTMAX_LAYER_H	softmax_layer.h	2;"	d
+TA_HELLO_WORLD_UUID	ca_cmds.h	6;"	d
+TA_TEE_SHADOW_UUID	ca_cmds.h	18;"	d
+TIME	utils.h	49;"	d
+TWO_PI	utils.h	56;"	d
+UTILS_H	utils.h	2;"	d
+activate	activations.c	/^float activate(float x, ACTIVATION a)$/;"	f
+activate_array	activations.c	/^void activate_array(float *x, const int n, const ACTIVATION a)$/;"	f
+add_bias	batchnorm_layer.c	/^void add_bias(float *output, float *biases, int batch, int n, int size)$/;"	f
+add_bias_nhwc	batchnorm_layer.c	/^void add_bias_nhwc(float *output, float *biases, int batch, int n, int size)$/;"	f
+alphanum_to_int	utils.c	/^int alphanum_to_int(char c)$/;"	f
+avgpool_layer	avgpool_layer.h	/^typedef layer avgpool_layer;$/;"	t
+batch	parser.c	/^    int batch;$/;"	m	struct:size_params	file:
+c	parser.c	/^    int c;$/;"	m	struct:size_params	file:
+constrain	utils.c	/^float constrain(float min, float max, float a)$/;"	f
+constrain_int	utils.c	/^int constrain_int(int a, int min, int max)$/;"	f
+copy_cpu	blas.c	/^void copy_cpu(int N, float *X, int INCX, float *Y, int INCY)$/;"	f
+copy_string	utils.c	/^char *copy_string(char *s)$/;"	f
+count_fields	utils.c	/^int count_fields(char *line)$/;"	f
+ctx	ca_cmds.c	/^TEEC_Context ctx;$/;"	v
+dist_array	utils.c	/^float dist_array(float *a, float *b, int n, int sub)$/;"	f
+dropout_layer	dropout_layer.h	/^typedef layer dropout_layer;$/;"	t
+error	utils.c	/^void error(const char *s)$/;"	f
+fgetl	utils.c	/^char *fgetl(FILE *fp)$/;"	f
+file_error	utils.c	/^void file_error(char *s)$/;"	f
+fill_cpu	blas.c	/^void fill_cpu(int N, float ALPHA, float *X, int INCX)$/;"	f
+forward_activation_layer	activation_layer.c	/^void forward_activation_layer(layer l, network net)$/;"	f
+forward_add_mask_layer	add_mask_layer.c	/^void forward_add_mask_layer(layer l, network net)$/;"	f
+forward_avgpool_layer	avgpool_layer.c	/^void forward_avgpool_layer(const avgpool_layer l, network net)$/;"	f
+forward_batchnorm_layer	batchnorm_layer.c	/^void forward_batchnorm_layer(layer l, network net)$/;"	f
+forward_dropout_layer	dropout_layer.c	/^void forward_dropout_layer(dropout_layer l, network net)$/;"	f
+forward_linear_transform_layer	linear_transform_layer.c	/^void forward_linear_transform_layer(layer l, network net)$/;"	f
+forward_network	network.c	/^void forward_network(network *netp)$/;"	f
+forward_shuffle_channel_layer	shuffle_channel_layer.c	/^void forward_shuffle_channel_layer(layer l, network net)$/;"	f
+forward_softmax_layer	softmax_layer.c	/^void forward_softmax_layer(const softmax_layer l, network net)$/;"	f
+free_layer	layer.c	/^void free_layer(layer l)$/;"	f
+free_list	list.c	/^void free_list(list *l)$/;"	f
+free_list_contents	list.c	/^void free_list_contents(list *l)$/;"	f
+free_network	network.c	/^void free_network(network *net)$/;"	f
+free_node	list.c	/^void free_node(node *n)$/;"	f
+free_ptrs	utils.c	/^void free_ptrs(void **ptrs, int n)$/;"	f
+free_section	parser.c	/^void free_section(section *s)$/;"	f
+get_activation	activations.c	/^ACTIVATION get_activation(char *s)$/;"	f
+get_activation_string	activations.c	/^char *get_activation_string(ACTIVATION a)$/;"	f
+get_layer_string	network.c	/^char *get_layer_string(LAYER_TYPE a)$/;"	f
+get_network_output_layer	network.c	/^layer get_network_output_layer(network *net)$/;"	f
+get_predicted_class_network	network.c	/^int get_predicted_class_network(network *net)$/;"	f
+h	parser.c	/^    int h;$/;"	m	struct:size_params	file:
+index	parser.c	/^    int index;$/;"	m	struct:size_params	file:
+inputs	parser.c	/^    int inputs;$/;"	m	struct:size_params	file:
+int_index	utils.c	/^int int_index(int *a, int val, int n)$/;"	f
+int_to_alphanum	utils.c	/^char int_to_alphanum(int i)$/;"	f
+is_network	parser.c	/^int is_network(section *s)$/;"	f
+key	option_list.h	/^    char *key;$/;"	m	struct:__anon2
+kvp	option_list.h	/^} kvp;$/;"	t	typeref:struct:__anon2
+list_insert	list.c	/^void list_insert(list *l, void *val)$/;"	f
+list_pop	list.c	/^void *list_pop(list *l){$/;"	f
+list_to_array	list.c	/^void **list_to_array(list *l)$/;"	f
+load_add_mask_weights	parser.c	/^void load_add_mask_weights(layer l, FILE *fp)$/;"	f
+load_add_mask_weights_ca	parser.c	/^void load_add_mask_weights_ca(int id,int ta_netid,  layer l, FILE *fp)$/;"	f
+load_batchnorm_weights	parser.c	/^void load_batchnorm_weights(layer l, FILE *fp)$/;"	f
+load_batchnorm_weights_ca	parser.c	/^void load_batchnorm_weights_ca(int id,int ta_netid,  layer l, FILE *fp)$/;"	f
+load_linear_transform_weights	parser.c	/^void load_linear_transform_weights(layer l, FILE *fp)$/;"	f
+load_linear_transform_weights_ca	parser.c	/^void load_linear_transform_weights_ca(int id,int ta_netid,  layer l, FILE *fp)$/;"	f
+load_network	network.c	/^network *load_network(char *cfg, char *weights, int clear)$/;"	f
+load_network_ca	network.c	/^network *load_network_ca(char *cfg, char *weights, int clear) {$/;"	f
+load_shuffle_channel_weights	parser.c	/^void load_shuffle_channel_weights(layer l, FILE *fp)$/;"	f
+load_shuffle_channel_weights_ca	parser.c	/^void load_shuffle_channel_weights_ca(int id,int ta_netid,  layer l, FILE *fp)$/;"	f
+load_weights	parser.c	/^void load_weights(network *net, char *filename)$/;"	f
+load_weights_ca	parser.c	/^void load_weights_ca(network *net, char *filename)$/;"	f
+load_weights_ca_cmd	ca_cmds.c	/^void load_weights_ca_cmd(int ta_netid, int layer_id, void *weights, int weight_idx, size_t length)$/;"	f
+load_weights_upto	parser.c	/^void load_weights_upto(network *net, char *filename, int start, int cutoff)$/;"	f
+mag_array	utils.c	/^float mag_array(float *a, int n)$/;"	f
+make_activation_layer	activation_layer.c	/^layer make_activation_layer(int batch, int inputs, ACTIVATION activation)$/;"	f
+make_add_mask_layer	add_mask_layer.c	/^layer make_add_mask_layer(int batch, int h, int w, int c)$/;"	f
+make_avgpool_layer	avgpool_layer.c	/^avgpool_layer make_avgpool_layer(int batch, int w, int h, int c)$/;"	f
+make_batchnorm_layer	batchnorm_layer.c	/^layer make_batchnorm_layer(int batch, int w, int h, int c)$/;"	f
+make_dropout_layer	dropout_layer.c	/^dropout_layer make_dropout_layer(int batch, int inputs, float probability)$/;"	f
+make_linear_transform_layer	linear_transform_layer.c	/^layer make_linear_transform_layer(int batch, int h, int w, int c, int units)$/;"	f
+make_list	list.c	/^list *make_list()$/;"	f
+make_network	network.c	/^network *make_network(int n)$/;"	f
+make_shuffle_channel_layer	shuffle_channel_layer.c	/^layer make_shuffle_channel_layer(int batch, int h, int w, int c)$/;"	f
+make_softmax_layer	softmax_layer.c	/^softmax_layer make_softmax_layer(int batch, int inputs, int groups)$/;"	f
+malloc_error	utils.c	/^void malloc_error()$/;"	f
+max_index	utils.c	/^int max_index(float *a, int n)$/;"	f
+max_int_index	utils.c	/^int max_int_index(int *a, int n)$/;"	f
+mean_array	utils.c	/^float mean_array(float *a, int n)$/;"	f
+mean_arrays	utils.c	/^void mean_arrays(float **a, int n, int els, float *avg)$/;"	f
+mean_cpu	blas.c	/^void mean_cpu(float *x, int batch, int filters, int spatial, float *mean)$/;"	f
+mse_array	utils.c	/^float mse_array(float *a, int n)$/;"	f
+net	parser.c	/^    network *net;$/;"	m	struct:size_params	file:
+network_height	network.c	/^int network_height(network *net){return net->h;}$/;"	f
+network_inputs	network.c	/^int network_inputs(network *net)$/;"	f
+network_output	network.c	/^float *network_output(network *net)$/;"	f
+network_output_layer	network.c	/^layer network_output_layer(network *net)$/;"	f
+network_outputs	network.c	/^int network_outputs(network *net)$/;"	f
+network_predict	network.c	/^float *network_predict(network *net, float *input)$/;"	f
+network_predict_ca	network.c	/^float *network_predict_ca(network *net, float *input) {$/;"	f
+network_predict_ca_cmd	ca_cmds.c	/^void network_predict_ca_cmd(int ta_netid, void *input, int in_len, void *output, int out_len)$/;"	f
+network_width	network.c	/^int network_width(network *net){return net->w;}$/;"	f
+noact_activate	activations.h	/^static inline float noact_activate(float x){return x;}$/;"	f
+normalize_array	utils.c	/^void normalize_array(float *a, int n)$/;"	f
+normalize_cpu	blas.c	/^void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)$/;"	f
+normalize_cpu_nhwc	blas.c	/^void normalize_cpu_nhwc(float *x, float *mean, float *variance, int batch, int filters, int spatial)$/;"	f
+one_hot_encode	utils.c	/^float **one_hot_encode(float *a, int n, int k)$/;"	f
+option_find	option_list.c	/^char *option_find(list *l, char *key)$/;"	f
+option_find_float	option_list.c	/^float option_find_float(list *l, char *key, float def)$/;"	f
+option_find_float_quiet	option_list.c	/^float option_find_float_quiet(list *l, char *key, float def)$/;"	f
+option_find_int	option_list.c	/^int option_find_int(list *l, char *key, int def)$/;"	f
+option_find_int_quiet	option_list.c	/^int option_find_int_quiet(list *l, char *key, int def)$/;"	f
+option_find_str	option_list.c	/^char *option_find_str(list *l, char *key, char *def)$/;"	f
+option_insert	option_list.c	/^void option_insert(list *l, char *key, char *val)$/;"	f
+option_unused	option_list.c	/^void option_unused(list *l)$/;"	f
+options	parser.c	/^    list *options;$/;"	m	struct:__anon1	file:
+parse_activation	parser.c	/^layer parse_activation(list *options, size_params params)$/;"	f
+parse_add_mask	parser.c	/^layer parse_add_mask(list *options, size_params params)$/;"	f
+parse_avgpool	parser.c	/^avgpool_layer parse_avgpool(list *options, size_params params)$/;"	f
+parse_batchnorm	parser.c	/^layer parse_batchnorm(list *options, size_params params)$/;"	f
+parse_csv_line	utils.c	/^list *parse_csv_line(char *line)$/;"	f
+parse_dropout	parser.c	/^dropout_layer parse_dropout(list *options, size_params params)$/;"	f
+parse_fields	utils.c	/^float *parse_fields(char *line, int n)$/;"	f
+parse_linear_transform	parser.c	/^layer parse_linear_transform(list *options, size_params params)$/;"	f
+parse_net_options	parser.c	/^void parse_net_options(list *options, network *net)$/;"	f
+parse_network_cfg	parser.c	/^network *parse_network_cfg(char *filename)$/;"	f
+parse_network_cfg_ca	parser.c	/^network *parse_network_cfg_ca(char *filename)$/;"	f
+parse_network_cfg_ca_cmd	ca_cmds.c	/^int parse_network_cfg_ca_cmd(char *cfg_buf) {$/;"	f
+parse_network_cfg_wrapper	parser.c	/^network *parse_network_cfg_wrapper(char *filename)$/;"	f
+parse_shuffle_channel	parser.c	/^layer parse_shuffle_channel(list *options, size_params params)$/;"	f
+parse_softmax	parser.c	/^layer parse_softmax(list *options, size_params params)$/;"	f
+pm	utils.c	/^void pm(int M, int N, float *A)$/;"	f
+print_statistics	utils.c	/^void print_statistics(float *a, int n)$/;"	f
+read_all	utils.c	/^void read_all(int fd, char *buffer, size_t bytes)$/;"	f
+read_all_fail	utils.c	/^int read_all_fail(int fd, char *buffer, size_t bytes)$/;"	f
+read_cfg	parser.c	/^list *read_cfg(char *filename)$/;"	f
+read_cfg_from_buf	parser.c	/^list *read_cfg_from_buf(char * cfg_buf)$/;"	f
+read_data_cfg	option_list.c	/^list *read_data_cfg(char *filename)$/;"	f
+read_file	utils.c	/^unsigned char *read_file(char *filename)$/;"	f
+read_int	utils.c	/^int read_int(int fd)$/;"	f
+read_option	option_list.c	/^int read_option(char *s, list *options)$/;"	f
+relu6_activate	activations.h	/^static inline float relu6_activate(float x){return (x < 0.) ? 0 : (6.0 < x) ? 6.0: x;}$/;"	f
+relu_activate	activations.h	/^static inline float relu_activate(float x){return x*(x>0);}$/;"	f
+resize_avgpool_layer	avgpool_layer.c	/^void resize_avgpool_layer(avgpool_layer *l, int w, int h)$/;"	f
+save_add_mask_weights	parser.c	/^void save_add_mask_weights(layer l, FILE *fp)$/;"	f
+save_batchnorm_weights	parser.c	/^void save_batchnorm_weights(layer l, FILE *fp)$/;"	f
+save_linear_transform_weights	parser.c	/^void save_linear_transform_weights(layer l, FILE *fp)$/;"	f
+save_shuffle_channel_weights	parser.c	/^void save_shuffle_channel_weights(layer l, FILE *fp)$/;"	f
+save_weights	parser.c	/^void save_weights(network *net, char *filename)$/;"	f
+save_weights_upto	parser.c	/^void save_weights_upto(network *net, char *filename, int cutoff)$/;"	f
+scale_array	utils.c	/^void scale_array(float *a, int n, float s)$/;"	f
+scale_bias	batchnorm_layer.c	/^void scale_bias(float *output, float *scales, int batch, int n, int size)$/;"	f
+scale_bias_nhwc	batchnorm_layer.c	/^void scale_bias_nhwc(float *output, float *scales, int batch, int n, int size)$/;"	f
+sec	utils.c	/^float sec(clock_t clocks)$/;"	f
+section	parser.c	/^}section;$/;"	t	typeref:struct:__anon1	file:
+sess	ca_cmds.c	/^TEEC_Session sess;$/;"	v
+set_batch_network	network.c	/^void set_batch_network(network *net, int b)$/;"	f
+setup_tee_session	ca_cmds.c	/^void setup_tee_session(void)$/;"	f
+size_params	parser.c	/^typedef struct size_params{$/;"	s	file:
+size_params	parser.c	/^} size_params;$/;"	t	typeref:struct:size_params	file:
+softmax	blas.c	/^void softmax(float *input, int n, float temp, int stride, float *output)$/;"	f
+softmax_cpu	blas.c	/^void softmax_cpu(float *input, int n, int batch, int batch_offset, int groups, int group_offset, int stride, float temp, float *output)$/;"	f
+softmax_layer	softmax_layer.h	/^typedef layer softmax_layer;$/;"	t
+split_str	utils.c	/^list *split_str(char *s, char delim)$/;"	f
+string_to_layer_type	parser.c	/^LAYER_TYPE string_to_layer_type(char * type)$/;"	f
+strip	utils.c	/^void strip(char *s)$/;"	f
+strip_char	utils.c	/^void strip_char(char *s, char bad)$/;"	f
+sum_array	utils.c	/^float sum_array(float *a, int n)$/;"	f
+tanh_activate	activations.h	/^static inline float tanh_activate(float x){return (exp(2*x)-1)\/(exp(2*x)+1);}$/;"	f
+teardown_tee_session	ca_cmds.c	/^void teardown_tee_session(void)$/;"	f
+tee_initialized	ca_cmds.c	/^int tee_initialized = 0;$/;"	v
+top_k	utils.c	/^void top_k(float *a, int n, int k, int *index)$/;"	f
+top_predictions	network.c	/^void top_predictions(network *net, int k, int *index)$/;"	f
+translate_array	utils.c	/^void translate_array(float *a, int n, float s)$/;"	f
+type	parser.c	/^    char *type;$/;"	m	struct:__anon1	file:
+used	option_list.h	/^    int used;$/;"	m	struct:__anon2
+val	option_list.h	/^    char *val;$/;"	m	struct:__anon2
+variance_array	utils.c	/^float variance_array(float *a, int n)$/;"	f
+variance_cpu	blas.c	/^void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)$/;"	f
+w	parser.c	/^    int w;$/;"	m	struct:size_params	file:
+what_time_is_it_now	utils.c	/^double what_time_is_it_now()$/;"	f
+write_all	utils.c	/^void write_all(int fd, char *buffer, size_t bytes)$/;"	f
+write_all_fail	utils.c	/^int write_all_fail(int fd, char *buffer, size_t bytes)$/;"	f
+write_int	utils.c	/^void write_int(int fd, int n)$/;"	f
diff --git a/third_party/optee_delegate/darknet_ca/src/utils.c b/third_party/optee_delegate/darknet_ca/src/utils.c
new file mode 100644
index 0000000..418a1cb
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/utils.c
@@ -0,0 +1,476 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <assert.h>
+#include <unistd.h>
+#include <float.h>
+#include <limits.h>
+#include <time.h>
+#include <sys/time.h>
+
+#include "utils.h"
+
+
+/*
+// old timing. is it better? who knows!!
+double get_wall_time()
+{
+    struct timeval time;
+    if (gettimeofday(&time,NULL)){
+        return 0;
+    }
+    return (double)time.tv_sec + (double)time.tv_usec * .000001;
+}
+*/
+
+double what_time_is_it_now()
+{
+    struct timeval time;
+    if (gettimeofday(&time,NULL)){
+        return 0;
+    }
+    return (double)time.tv_sec + (double)time.tv_usec * .000001;
+}
+
+
+
+int alphanum_to_int(char c)
+{
+    return (c < 58) ? c - 48 : c-87;
+}
+char int_to_alphanum(int i)
+{
+    if (i == 36) return '.';
+    return (i < 10) ? i + 48 : i + 87;
+}
+
+void pm(int M, int N, float *A)
+{
+    int i,j;
+    for(i =0 ; i < M; ++i){
+        printf("%d ", i+1);
+        for(j = 0; j < N; ++j){
+            printf("%2.4f, ", A[i*N+j]);
+        }
+        printf("\n");
+    }
+    printf("\n");
+}
+
+float sec(clock_t clocks)
+{
+    return (float)clocks/CLOCKS_PER_SEC;
+}
+
+void top_k(float *a, int n, int k, int *index)
+{
+    int i,j;
+    for(j = 0; j < k; ++j) index[j] = -1;
+    for(i = 0; i < n; ++i){
+        int curr = i;
+        for(j = 0; j < k; ++j){
+            if((index[j] < 0) || a[curr] > a[index[j]]){
+                int swap = curr;
+                curr = index[j];
+                index[j] = swap;
+            }
+        }
+    }
+}
+
+void error(const char *s)
+{
+    perror(s);
+    assert(0);
+    exit(-1);
+}
+
+unsigned char *read_file(char *filename)
+{
+    FILE *fp = fopen(filename, "r");
+    size_t size;
+
+    if (fp == 0) {
+        LOGD("read file:%s error!\n",filename);
+        return NULL;
+    }
+
+    LOGD("read file:%s return not null!\n",filename);
+    fseek(fp, 0, SEEK_END); 
+    size = ftell(fp);
+    fseek(fp, 0, SEEK_SET); 
+
+    unsigned char *text = calloc(size+1, sizeof(char));
+    fread(text, 1, size, fp);
+    fclose(fp);
+    LOGD("read file:%s context:%s!\n",filename, text);
+    return text;
+}
+
+void malloc_error()
+{
+    LOGD("Malloc error\n");
+    exit(-1);
+}
+
+void file_error(char *s)
+{
+    LOGD("Couldn't open file: %s\n", s);
+    exit(0);
+}
+
+list *split_str(char *s, char delim)
+{
+    size_t i;
+    size_t len = strlen(s);
+    list *l = make_list();
+    list_insert(l, s);
+    for(i = 0; i < len; ++i){
+        if(s[i] == delim){
+            s[i] = '\0';
+            list_insert(l, &(s[i+1]));
+        }
+    }
+    return l;
+}
+
+void strip(char *s)
+{
+    size_t i;
+    size_t len = strlen(s);
+    size_t offset = 0;
+    for(i = 0; i < len; ++i){
+        char c = s[i];
+        if(c==' '||c=='\t'||c=='\n') ++offset;
+        else s[i-offset] = c;
+    }
+    s[len-offset] = '\0';
+}
+
+void strip_char(char *s, char bad)
+{
+    size_t i;
+    size_t len = strlen(s);
+    size_t offset = 0;
+    for(i = 0; i < len; ++i){
+        char c = s[i];
+        if(c==bad) ++offset;
+        else s[i-offset] = c;
+    }
+    s[len-offset] = '\0';
+}
+
+void free_ptrs(void **ptrs, int n)
+{
+    int i;
+    for(i = 0; i < n; ++i) free(ptrs[i]);
+    free(ptrs);
+}
+
+char *fgetl(FILE *fp)
+{
+    if(feof(fp)) return 0;
+    size_t size = 512;
+    char *line = malloc(size*sizeof(char));
+    if(!fgets(line, size, fp)){
+        free(line);
+        return 0;
+    }
+
+    size_t curr = strlen(line);
+
+    while((line[curr-1] != '\n') && !feof(fp)){
+        if(curr == size-1){
+            size *= 2;
+            line = realloc(line, size*sizeof(char));
+            if(!line) {
+                printf("%ld\n", size);
+                malloc_error();
+            }
+        }
+        size_t readsize = size-curr;
+        if(readsize > INT_MAX) readsize = INT_MAX-1;
+        fgets(&line[curr], readsize, fp);
+        curr = strlen(line);
+    }
+    if(line[curr-1] == '\n') line[curr-1] = '\0';
+
+    return line;
+}
+
+int read_int(int fd)
+{
+    int n = 0;
+    int next = read(fd, &n, sizeof(int));
+    if(next <= 0) return -1;
+    return n;
+}
+
+void write_int(int fd, int n)
+{
+    int next = write(fd, &n, sizeof(int));
+    if(next <= 0) error("read failed");
+}
+
+int read_all_fail(int fd, char *buffer, size_t bytes)
+{
+    size_t n = 0;
+    while(n < bytes){
+        int next = read(fd, buffer + n, bytes-n);
+        if(next <= 0) return 1;
+        n += next;
+    }
+    return 0;
+}
+
+int write_all_fail(int fd, char *buffer, size_t bytes)
+{
+    size_t n = 0;
+    while(n < bytes){
+        size_t next = write(fd, buffer + n, bytes-n);
+        if(next <= 0) return 1;
+        n += next;
+    }
+    return 0;
+}
+
+void read_all(int fd, char *buffer, size_t bytes)
+{
+    size_t n = 0;
+    while(n < bytes){
+        int next = read(fd, buffer + n, bytes-n);
+        if(next <= 0) error("read failed");
+        n += next;
+    }
+}
+
+void write_all(int fd, char *buffer, size_t bytes)
+{
+    size_t n = 0;
+    while(n < bytes){
+        size_t next = write(fd, buffer + n, bytes-n);
+        if(next <= 0) error("write failed");
+        n += next;
+    }
+}
+
+
+char *copy_string(char *s)
+{
+    char *copy = malloc(strlen(s)+1);
+    strncpy(copy, s, strlen(s)+1);
+    return copy;
+}
+
+list *parse_csv_line(char *line)
+{
+    list *l = make_list();
+    char *c, *p;
+    int in = 0;
+    for(c = line, p = line; *c != '\0'; ++c){
+        if(*c == '"') in = !in;
+        else if(*c == ',' && !in){
+            *c = '\0';
+            list_insert(l, copy_string(p));
+            p = c+1;
+        }
+    }
+    list_insert(l, copy_string(p));
+    return l;
+}
+
+int count_fields(char *line)
+{
+    int count = 0;
+    int done = 0;
+    char *c;
+    for(c = line; !done; ++c){
+        done = (*c == '\0');
+        if(*c == ',' || done) ++count;
+    }
+    return count;
+}
+
+float *parse_fields(char *line, int n)
+{
+    float *field = calloc(n, sizeof(float));
+    char *c, *p, *end;
+    int count = 0;
+    int done = 0;
+    for(c = line, p = line; !done; ++c){
+        done = (*c == '\0');
+        if(*c == ',' || done){
+            *c = '\0';
+            field[count] = strtod(p, &end);
+            if(p == c) field[count] = nan("");
+            if(end != c && (end != c-1 || *end != '\r')) field[count] = nan(""); //DOS file formats!
+            p = c+1;
+            ++count;
+        }
+    }
+    return field;
+}
+
+float sum_array(float *a, int n)
+{
+    int i;
+    float sum = 0;
+    for(i = 0; i < n; ++i) sum += a[i];
+    return sum;
+}
+
+float mean_array(float *a, int n)
+{
+    return sum_array(a,n)/n;
+}
+
+void mean_arrays(float **a, int n, int els, float *avg)
+{
+    int i;
+    int j;
+    memset(avg, 0, els*sizeof(float));
+    for(j = 0; j < n; ++j){
+        for(i = 0; i < els; ++i){
+            avg[i] += a[j][i];
+        }
+    }
+    for(i = 0; i < els; ++i){
+        avg[i] /= n;
+    }
+}
+
+void print_statistics(float *a, int n)
+{
+    float m = mean_array(a, n);
+    float v = variance_array(a, n);
+    printf("MSE: %.6f, Mean: %.6f, Variance: %.6f\n", mse_array(a, n), m, v);
+}
+
+float variance_array(float *a, int n)
+{
+    int i;
+    float sum = 0;
+    float mean = mean_array(a, n);
+    for(i = 0; i < n; ++i) sum += (a[i] - mean)*(a[i]-mean);
+    float variance = sum/n;
+    return variance;
+}
+
+int constrain_int(int a, int min, int max)
+{
+    if (a < min) return min;
+    if (a > max) return max;
+    return a;
+}
+
+float constrain(float min, float max, float a)
+{
+    if (a < min) return min;
+    if (a > max) return max;
+    return a;
+}
+
+float dist_array(float *a, float *b, int n, int sub)
+{
+    int i;
+    float sum = 0;
+    for(i = 0; i < n; i += sub) sum += pow(a[i]-b[i], 2);
+    return sqrt(sum);
+}
+
+float mse_array(float *a, int n)
+{
+    int i;
+    float sum = 0;
+    for(i = 0; i < n; ++i) sum += a[i]*a[i];
+    return sqrt(sum/n);
+}
+
+void normalize_array(float *a, int n)
+{
+    int i;
+    float mu = mean_array(a,n);
+    float sigma = sqrt(variance_array(a,n));
+    for(i = 0; i < n; ++i){
+        a[i] = (a[i] - mu)/sigma;
+    }
+    mu = mean_array(a,n);
+    sigma = sqrt(variance_array(a,n));
+}
+
+void translate_array(float *a, int n, float s)
+{
+    int i;
+    for(i = 0; i < n; ++i){
+        a[i] += s;
+    }
+}
+
+float mag_array(float *a, int n)
+{
+    int i;
+    float sum = 0;
+    for(i = 0; i < n; ++i){
+        sum += a[i]*a[i];   
+    }
+    return sqrt(sum);
+}
+
+void scale_array(float *a, int n, float s)
+{
+    int i;
+    for(i = 0; i < n; ++i){
+        a[i] *= s;
+    }
+}
+
+int max_int_index(int *a, int n)
+{
+    if(n <= 0) return -1;
+    int i, max_i = 0;
+    int max = a[0];
+    for(i = 1; i < n; ++i){
+        if(a[i] > max){
+            max = a[i];
+            max_i = i;
+        }
+    }
+    return max_i;
+}
+
+int max_index(float *a, int n)
+{
+    if(n <= 0) return -1;
+    int i, max_i = 0;
+    float max = a[0];
+    for(i = 1; i < n; ++i){
+        if(a[i] > max){
+            max = a[i];
+            max_i = i;
+        }
+    }
+    return max_i;
+}
+
+int int_index(int *a, int val, int n)
+{
+    int i;
+    for(i = 0; i < n; ++i){
+        if(a[i] == val) return i;
+    }
+    return -1;
+}
+
+float **one_hot_encode(float *a, int n, int k)
+{
+    int i;
+    float **t = calloc(n, sizeof(float*));
+    for(i = 0; i < n; ++i){
+        t[i] = calloc(k, sizeof(float));
+        int index = (int)a[i];
+        t[i][index] = 1;
+    }
+    return t;
+}
+
diff --git a/third_party/optee_delegate/darknet_ca/src/utils.h b/third_party/optee_delegate/darknet_ca/src/utils.h
new file mode 100644
index 0000000..1c9d922
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/src/utils.h
@@ -0,0 +1,96 @@
+#ifndef UTILS_H
+#define UTILS_H
+#include <stdio.h>
+#include <time.h>
+#include <android/log.h>
+#include "darknet.h"
+#include "list.h"
+
+#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "com.tflitedemo ZC native", __VA_ARGS__)
+//#define DEBUG_WEIGHTS
+
+#ifdef DEBUG_WEIGHTS
+/* dump weigths first 8 bytes */
+#define DUMPW4F(TAG, size, pw) fprintf(stderr, TAG " bufsize:%d [0-7]: %6f %6f %6f %6f\n",size, \
+        pw[0], \
+        pw[1], \
+        pw[2], \
+        pw[3])
+
+#define DUMPW4I(TAG, size, pw) fprintf(stderr, TAG " bufsize:%d [0-7]: %6d %6d %6d %6d\n",size, \
+        pw[0], \
+        pw[1], \
+        pw[2], \
+        pw[3]) 
+
+/* dump weigths first 8 bytes */
+#define DUMPW8(TAG, size, pw) fprintf(stderr, TAG " bufsize:%d [0-7]: %3u %3u %3u %3u %3u %3u %3u %3u\n",size, \
+        ((unsigned char *)pw)[0], \
+        ((unsigned char *)pw)[1], \
+        ((unsigned char *)pw)[2], \
+        ((unsigned char *)pw)[3], \
+        ((unsigned char *)pw)[4], \
+        ((unsigned char *)pw)[5], \
+        ((unsigned char *)pw)[6], \
+        ((unsigned char *)pw)[7])
+
+#define DUMPW4(TAG, size, pw) fprintf(stderr, TAG " bufsize:%d [0-7]: %3u %3u %3u %3u\n",size, \
+        ((unsigned char *)pw)[0], \
+        ((unsigned char *)pw)[1], \
+        ((unsigned char *)pw)[2], \
+        ((unsigned char *)pw)[3]) 
+#else
+
+#define DUMPW4F(TAG, size, pw) 
+#define DUMPW4I(TAG, size, pw) 
+#define DUMPW8(TAG, size, pw)
+#define DUMPW4(TAG, size, pw)
+
+#endif
+
+#define TIME(a) \
+    do { \
+    double start = what_time_is_it_now(); \
+    a; \
+    printf("%s took: %f seconds\n", #a, what_time_is_it_now() - start); \
+    } while (0)
+
+#define TWO_PI 6.2831853071795864769252866f
+
+double what_time_is_it_now();
+void shuffle(void *arr, size_t n, size_t size);
+void sorta_shuffle(void *arr, size_t n, size_t size, size_t sections);
+void free_ptrs(void **ptrs, int n);
+int alphanum_to_int(char c);
+char int_to_alphanum(int i);
+int read_int(int fd);
+void write_int(int fd, int n);
+void read_all(int fd, char *buffer, size_t bytes);
+void write_all(int fd, char *buffer, size_t bytes);
+int read_all_fail(int fd, char *buffer, size_t bytes);
+int write_all_fail(int fd, char *buffer, size_t bytes);
+void find_replace(char *str, char *orig, char *rep, char *output);
+void malloc_error();
+void file_error(char *s);
+void strip(char *s);
+void strip_char(char *s, char bad);
+list *split_str(char *s, char delim);
+char *fgetl(FILE *fp);
+list *parse_csv_line(char *line);
+char *copy_string(char *s);
+int count_fields(char *line);
+float *parse_fields(char *line, int n);
+void translate_array(float *a, int n, float s);
+float constrain(float min, float max, float a);
+int constrain_int(int a, int min, int max);
+float rand_scale(float s);
+int rand_int(int min, int max);
+void mean_arrays(float **a, int n, int els, float *avg);
+float dist_array(float *a, float *b, int n, int sub);
+float **one_hot_encode(float *a, int n, int k);
+float sec(clock_t clocks);
+void print_statistics(float *a, int n);
+int int_index(int *a, int val, int n);
+
+#endif
+
diff --git a/third_party/optee_delegate/darknet_ca/tags b/third_party/optee_delegate/darknet_ca/tags
new file mode 100644
index 0000000..0191caa
--- /dev/null
+++ b/third_party/optee_delegate/darknet_ca/tags
@@ -0,0 +1,908 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+ACTIVATION	include/darknet.h	/^} ACTIVATION;$/;"	t	typeref:enum:__anon6
+ACTIVATIONS_H	activations.h	2;"	d
+ACTIVATION_LAYER_H	activation_layer.h	2;"	d
+ACTIVE	include/darknet.h	/^    ACTIVE,$/;"	e	enum:__anon9
+ADD	include/darknet.h	/^    MULT, ADD, SUB, DIV$/;"	e	enum:__anon8
+ADD_MASK	include/darknet.h	/^    ADD_MASK,$/;"	e	enum:__anon9
+ADD_MASK_LAYER_H	add_mask_layer.h	2;"	d
+AVGPOOL	include/darknet.h	/^    AVGPOOL,$/;"	e	enum:__anon9
+AVGPOOL_LAYER_H	avgpool_layer.h	2;"	d
+B1	include/darknet.h	/^    float B1;$/;"	m	struct:__anon11
+B1	include/darknet.h	/^    float B1;$/;"	m	struct:network
+B2	include/darknet.h	/^    float B2;$/;"	m	struct:__anon11
+B2	include/darknet.h	/^    float B2;$/;"	m	struct:network
+BATCHNORM	include/darknet.h	/^    BATCHNORM,$/;"	e	enum:__anon9
+BATCHNORM_LAYER_H	batchnorm_layer.h	2;"	d
+BINARY_ACTIVATION	include/darknet.h	/^} BINARY_ACTIVATION;$/;"	t	typeref:enum:__anon8
+BLANK	include/darknet.h	/^    BLANK$/;"	e	enum:__anon9
+BLAS_H	blas.h	2;"	d
+BLOCK	include/darknet.h	9;"	d
+BMP	include/darknet.h	/^    PNG, BMP, TGA, JPG$/;"	e	enum:__anon7
+CAPTCHA_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+CLASSIFICATION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+COMPARE_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+CONNECTED	include/darknet.h	/^    CONNECTED,$/;"	e	enum:__anon9
+CONSTANT	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+CONVOLUTIONAL	include/darknet.h	/^    CONVOLUTIONAL,$/;"	e	enum:__anon9
+COST	include/darknet.h	/^    COST,$/;"	e	enum:__anon9
+COST_TYPE	include/darknet.h	/^} COST_TYPE;$/;"	t	typeref:enum:__anon10
+CRNN	include/darknet.h	/^    CRNN,$/;"	e	enum:__anon9
+CROP	include/darknet.h	/^    CROP,$/;"	e	enum:__anon9
+DARKNET_API	include/darknet.h	2;"	d
+DECONVOLUTIONAL	include/darknet.h	/^    DECONVOLUTIONAL,$/;"	e	enum:__anon9
+DETECTION	include/darknet.h	/^    DETECTION,$/;"	e	enum:__anon9
+DETECTION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+DET_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+DIV	include/darknet.h	/^    MULT, ADD, SUB, DIV$/;"	e	enum:__anon8
+DROPOUT	include/darknet.h	/^    DROPOUT,$/;"	e	enum:__anon9
+DROPOUT_LAYER_H	dropout_layer.h	2;"	d
+DUMPW4	utils.h	35;"	d
+DUMPW4	utils.h	45;"	d
+DUMPW4F	utils.h	12;"	d
+DUMPW4F	utils.h	42;"	d
+DUMPW4I	utils.h	18;"	d
+DUMPW4I	utils.h	43;"	d
+DUMPW8	utils.h	25;"	d
+DUMPW8	utils.h	44;"	d
+ELU	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+EXP	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+GRU	include/darknet.h	/^    GRU,$/;"	e	enum:__anon9
+HARDTAN	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+IMAGE_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+IMTYPE	include/darknet.h	/^} IMTYPE;$/;"	t	typeref:enum:__anon7
+INSTANCE_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+ISEG	include/darknet.h	/^    ISEG,$/;"	e	enum:__anon9
+ISEG_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+JPG	include/darknet.h	/^    PNG, BMP, TGA, JPG$/;"	e	enum:__anon7
+L1	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+L2NORM	include/darknet.h	/^    L2NORM,$/;"	e	enum:__anon9
+LAYER_TYPE	include/darknet.h	/^} LAYER_TYPE;$/;"	t	typeref:enum:__anon9
+LEAKY	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+LETTERBOX_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+LHTAN	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+LINEAR	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+LINEAR_TRANSFORM	include/darknet.h	/^    LINEAR_TRANSFORM,$/;"	e	enum:__anon9
+LINEAR_TRANSFORM_LAYER_H	linear_transform_layer.h	2;"	d
+LIST_H	list.h	2;"	d
+LOCAL	include/darknet.h	/^    LOCAL,$/;"	e	enum:__anon9
+LOGGY	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+LOGISTIC	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+LOGXENT	include/darknet.h	/^    LOGXENT,$/;"	e	enum:__anon9
+LSTM	include/darknet.h	/^    LSTM,$/;"	e	enum:__anon9
+MASKED	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+MAXPOOL	include/darknet.h	/^    MAXPOOL,$/;"	e	enum:__anon9
+MULT	include/darknet.h	/^    MULT, ADD, SUB, DIV$/;"	e	enum:__anon8
+NETWORK	include/darknet.h	/^    NETWORK,$/;"	e	enum:__anon9
+NETWORK_H	network.h	3;"	d
+NOACT	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+NORMALIZATION	include/darknet.h	/^    NORMALIZATION,$/;"	e	enum:__anon9
+OLD_CLASSIFICATION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+OPTION_LIST_H	option_list.h	2;"	d
+PARSER_H	parser.h	2;"	d
+PLSE	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+PNG	include/darknet.h	/^    PNG, BMP, TGA, JPG$/;"	e	enum:__anon7
+POLY	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+RAMP	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+RANDOM	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+REGION	include/darknet.h	/^    REGION,$/;"	e	enum:__anon9
+REGION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+REGRESSION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+RELIE	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+RELU	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+RELU6	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+REORG	include/darknet.h	/^    REORG,$/;"	e	enum:__anon9
+RNN	include/darknet.h	/^    RNN,$/;"	e	enum:__anon9
+ROUTE	include/darknet.h	/^    ROUTE,$/;"	e	enum:__anon9
+SECRET_NUM	include/darknet.h	24;"	d
+SEG	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+SEGMENTATION_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+SELU	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+SHORTCUT	include/darknet.h	/^    SHORTCUT,$/;"	e	enum:__anon9
+SHUFFLE_CHANNEL	include/darknet.h	/^    SHUFFLE_CHANNEL,$/;"	e	enum:__anon9
+SHUFFLE_CHANNEL_LAYER_H	shuffle_channel_layer.h	2;"	d
+SIG	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+SMOOTH	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+SOFTMAX	include/darknet.h	/^    SOFTMAX,$/;"	e	enum:__anon9
+SOFTMAX_LAYER_H	softmax_layer.h	2;"	d
+SSE	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+STAIR	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+STEP	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+STEPS	include/darknet.h	/^    CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM$/;"	e	enum:__anon12
+STUDY_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+SUB	include/darknet.h	/^    MULT, ADD, SUB, DIV$/;"	e	enum:__anon8
+SUPER_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+SWAG_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+TAG_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+TANH	include/darknet.h	/^    LOGISTIC, RELU, RELIE, LINEAR, RAMP, TANH, PLSE, LEAKY, ELU, LOGGY, STAIR, HARDTAN, LHTAN, SELU,NOACT, RELU6$/;"	e	enum:__anon6
+TGA	include/darknet.h	/^    PNG, BMP, TGA, JPG$/;"	e	enum:__anon7
+TIME	utils.h	49;"	d
+TWO_PI	utils.h	56;"	d
+UPSAMPLE	include/darknet.h	/^    UPSAMPLE,$/;"	e	enum:__anon9
+UTILS_H	utils.h	2;"	d
+WGAN	include/darknet.h	/^    SSE, MASKED, L1, SEG, SMOOTH,WGAN$/;"	e	enum:__anon10
+WRITING_DATA	include/darknet.h	/^    CLASSIFICATION_DATA, DETECTION_DATA, CAPTCHA_DATA, REGION_DATA, IMAGE_DATA, COMPARE_DATA, WRITING_DATA, SWAG_DATA, TAG_DATA, OLD_CLASSIFICATION_DATA, STUDY_DATA, DET_DATA, SUPER_DATA, LETTERBOX_DATA, REGRESSION_DATA, SEGMENTATION_DATA, INSTANCE_DATA, ISEG_DATA$/;"	e	enum:__anon17
+X	include/darknet.h	/^    matrix X;$/;"	m	struct:__anon16
+XNOR	include/darknet.h	/^    XNOR,$/;"	e	enum:__anon9
+YOLO	include/darknet.h	/^    YOLO,$/;"	e	enum:__anon9
+absolute	include/darknet.h	/^    int absolute;$/;"	m	struct:layer
+activate	activations.c	/^float activate(float x, ACTIVATION a)$/;"	f
+activate_array	activations.c	/^void activate_array(float *x, const int n, const ACTIVATION a)$/;"	f
+activation	include/darknet.h	/^    ACTIVATION activation;$/;"	m	struct:layer
+adam	include/darknet.h	/^    int adam;$/;"	m	struct:__anon11
+adam	include/darknet.h	/^    int adam;$/;"	m	struct:network
+alpha	include/darknet.h	/^    float alpha;$/;"	m	struct:layer
+alphanum_to_int	utils.c	/^int alphanum_to_int(char c)$/;"	f
+angle	include/darknet.h	/^    float angle;$/;"	m	struct:layer
+angle	include/darknet.h	/^    float angle;$/;"	m	struct:load_args
+angle	include/darknet.h	/^    float angle;$/;"	m	struct:network
+aspect	include/darknet.h	/^    float aspect;$/;"	m	struct:__anon13
+aspect	include/darknet.h	/^    float aspect;$/;"	m	struct:load_args
+aspect	include/darknet.h	/^    float aspect;$/;"	m	struct:network
+augment_args	include/darknet.h	/^} augment_args;$/;"	t	typeref:struct:__anon13
+avgpool_layer	avgpool_layer.h	/^typedef layer avgpool_layer;$/;"	t
+axpy_cpu	blas.c	/^void axpy_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)$/;"	f
+back	include/darknet.h	/^    node *back;$/;"	m	struct:list
+background	include/darknet.h	/^    int background;$/;"	m	struct:layer
+background	include/darknet.h	/^    int background;$/;"	m	struct:load_args
+backward	include/darknet.h	/^    void (*backward)  (struct layer, struct network);$/;"	m	struct:layer
+backward_activation_layer	activation_layer.c	/^void backward_activation_layer(layer l, network net)$/;"	f
+backward_activation_layer_gpu	activation_layer.c	/^void backward_activation_layer_gpu(layer l, network net)$/;"	f
+backward_avgpool_layer	avgpool_layer.c	/^void backward_avgpool_layer(const avgpool_layer l, network net)$/;"	f
+backward_batchnorm_layer	batchnorm_layer.c	/^void backward_batchnorm_layer(layer l, network net)$/;"	f
+backward_batchnorm_layer_gpu	batchnorm_layer.c	/^void backward_batchnorm_layer_gpu(layer l, network net)$/;"	f
+backward_dropout_layer	dropout_layer.c	/^void backward_dropout_layer(dropout_layer l, network net)$/;"	f
+backward_gpu	include/darknet.h	/^    void (*backward_gpu)  (struct layer, struct network);$/;"	m	struct:layer
+backward_network	network.c	/^void backward_network(network *netp)$/;"	f
+backward_network_gpu	network.c	/^void backward_network_gpu(network *netp)$/;"	f
+backward_scale_cpu	batchnorm_layer.c	/^void backward_scale_cpu(float *x_norm, float *delta, int batch, int n, int size, float *scale_updates)$/;"	f
+backward_softmax_layer	softmax_layer.c	/^void backward_softmax_layer(const softmax_layer l, network net)$/;"	f
+backward_softmax_layer_gpu	softmax_layer.c	/^void backward_softmax_layer_gpu(const softmax_layer layer, network net)$/;"	f
+basecfg	utils.c	/^char *basecfg(char *cfgfile)$/;"	f
+batch	include/darknet.h	/^    int batch;$/;"	m	struct:__anon11
+batch	include/darknet.h	/^    int batch;$/;"	m	struct:layer
+batch	include/darknet.h	/^    int batch;$/;"	m	struct:network
+batch	parser.c	/^    int batch;$/;"	m	struct:size_params	file:
+batch_normalize	include/darknet.h	/^    int batch_normalize;$/;"	m	struct:layer
+bbox	include/darknet.h	/^    box bbox;$/;"	m	struct:detection
+bd_algo	include/darknet.h	/^    cudnnConvolutionBwdDataAlgo_t bd_algo;$/;"	m	struct:layer
+beta	include/darknet.h	/^    float beta;$/;"	m	struct:layer
+bf_algo	include/darknet.h	/^    cudnnConvolutionBwdFilterAlgo_t bf_algo;$/;"	m	struct:layer
+bias_change_gpu	include/darknet.h	/^    float * bias_change_gpu;$/;"	m	struct:layer
+bias_m	include/darknet.h	/^    float * bias_m;$/;"	m	struct:layer
+bias_m_gpu	include/darknet.h	/^    float *bias_m_gpu;$/;"	m	struct:layer
+bias_match	include/darknet.h	/^    int bias_match;$/;"	m	struct:layer
+bias_updates	include/darknet.h	/^    float * bias_updates;$/;"	m	struct:layer
+bias_updates_gpu	include/darknet.h	/^    float * bias_updates_gpu;$/;"	m	struct:layer
+bias_v	include/darknet.h	/^    float * bias_v;$/;"	m	struct:layer
+bias_v_gpu	include/darknet.h	/^    float *bias_v_gpu;$/;"	m	struct:layer
+biases	include/darknet.h	/^    float * biases;$/;"	m	struct:layer
+biases_gpu	include/darknet.h	/^    float * biases_gpu;$/;"	m	struct:layer
+binary	include/darknet.h	/^    int binary;$/;"	m	struct:layer
+binary_input	include/darknet.h	/^    float * binary_input;$/;"	m	struct:layer
+binary_input_gpu	include/darknet.h	/^    float * binary_input_gpu;$/;"	m	struct:layer
+binary_weights	include/darknet.h	/^    float * binary_weights;$/;"	m	struct:layer
+binary_weights_gpu	include/darknet.h	/^    float * binary_weights_gpu;$/;"	m	struct:layer
+bn_bias	include/darknet.h	/^    int bn_bias;$/;"	m	struct:layer
+bottom	include/darknet.h	/^    float left, right, top, bottom;$/;"	m	struct:__anon18
+box	include/darknet.h	/^} box;$/;"	t	typeref:struct:__anon15
+box_label	include/darknet.h	/^} box_label;$/;"	t	typeref:struct:__anon18
+boxes	include/darknet.h	/^    box **boxes;$/;"	m	struct:__anon16
+burn_in	include/darknet.h	/^    int burn_in;$/;"	m	struct:network
+c	include/darknet.h	/^    int c;$/;"	m	struct:__anon14
+c	include/darknet.h	/^    int h, w, c;$/;"	m	struct:network
+c	include/darknet.h	/^    int h,w,c;$/;"	m	struct:layer
+c	parser.c	/^    int c;$/;"	m	struct:size_params	file:
+c_cpu	include/darknet.h	/^    float *c_cpu;$/;"	m	struct:layer
+c_gpu	include/darknet.h	/^    float *c_gpu;$/;"	m	struct:layer
+calc_network_cost	network.c	/^void calc_network_cost(network *netp)$/;"	f
+cell_cpu	include/darknet.h	/^    float *cell_cpu;$/;"	m	struct:layer
+cell_gpu	include/darknet.h	/^    float *cell_gpu;$/;"	m	struct:layer
+center	include/darknet.h	/^    int center;$/;"	m	struct:load_args
+center	include/darknet.h	/^    int center;$/;"	m	struct:network
+child	include/darknet.h	/^    int *child;$/;"	m	struct:__anon5
+class_scale	include/darknet.h	/^    float class_scale;$/;"	m	struct:layer
+classes	include/darknet.h	/^    int classes;$/;"	m	struct:__anon4
+classes	include/darknet.h	/^    int classes;$/;"	m	struct:detection
+classes	include/darknet.h	/^    int classes;$/;"	m	struct:layer
+classes	include/darknet.h	/^    int classes;$/;"	m	struct:load_args
+classfix	include/darknet.h	/^    int classfix;$/;"	m	struct:layer
+clip	include/darknet.h	/^    float clip;$/;"	m	struct:layer
+clip	include/darknet.h	/^    float clip;$/;"	m	struct:network
+cols	include/darknet.h	/^    int rows, cols;$/;"	m	struct:matrix
+combine_cpu	include/darknet.h	/^    float * combine_cpu;$/;"	m	struct:layer
+combine_delta_cpu	include/darknet.h	/^    float * combine_delta_cpu;$/;"	m	struct:layer
+combine_delta_gpu	include/darknet.h	/^    float * combine_delta_gpu;$/;"	m	struct:layer
+combine_gpu	include/darknet.h	/^    float * combine_gpu;$/;"	m	struct:layer
+compare_networks	network.c	/^void compare_networks(network *n1, network *n2, data test)$/;"	f
+concat	include/darknet.h	/^    float * concat;$/;"	m	struct:layer
+concat_delta	include/darknet.h	/^    float * concat_delta;$/;"	m	struct:layer
+concat_delta_gpu	include/darknet.h	/^    float * concat_delta_gpu;$/;"	m	struct:layer
+concat_gpu	include/darknet.h	/^    float * concat_gpu;$/;"	m	struct:layer
+const_cpu	blas.c	/^void const_cpu(int N, float ALPHA, float *X, int INCX)$/;"	f
+constrain	utils.c	/^float constrain(float min, float max, float a)$/;"	f
+constrain_int	utils.c	/^int constrain_int(int a, int min, int max)$/;"	f
+convDesc	include/darknet.h	/^    cudnnConvolutionDescriptor_t convDesc;$/;"	m	struct:layer
+coord_scale	include/darknet.h	/^    float coord_scale;$/;"	m	struct:layer
+coords	include/darknet.h	/^    int coords;$/;"	m	struct:layer
+coords	include/darknet.h	/^    int coords;$/;"	m	struct:load_args
+copy_cpu	blas.c	/^void copy_cpu(int N, float *X, int INCX, float *Y, int INCY)$/;"	f
+copy_string	utils.c	/^char *copy_string(char *s)$/;"	f
+cost	include/darknet.h	/^    float * cost;$/;"	m	struct:layer
+cost	include/darknet.h	/^    float *cost;$/;"	m	struct:network
+cost_type	include/darknet.h	/^    COST_TYPE cost_type;$/;"	m	struct:layer
+count_fields	utils.c	/^int count_fields(char *line)$/;"	f
+counts	include/darknet.h	/^    int   * counts;$/;"	m	struct:layer
+cweights	include/darknet.h	/^    char  * cweights;$/;"	m	struct:layer
+d	include/darknet.h	/^    data *d;$/;"	m	struct:load_args
+d	network.c	/^    data d;$/;"	m	struct:__anon1	file:
+data	include/darknet.h	/^    float *data;$/;"	m	struct:__anon14
+data	include/darknet.h	/^} data;$/;"	t	typeref:struct:__anon16
+data_type	include/darknet.h	/^} data_type;$/;"	t	typeref:enum:__anon17
+dc_cpu	include/darknet.h	/^    float *dc_cpu; $/;"	m	struct:layer
+dc_gpu	include/darknet.h	/^    float *dc_gpu; $/;"	m	struct:layer
+ddstTensorDesc	include/darknet.h	/^    cudnnTensorDescriptor_t dsrcTensorDesc, ddstTensorDesc;$/;"	m	struct:layer
+decay	include/darknet.h	/^    float decay;$/;"	m	struct:__anon11
+decay	include/darknet.h	/^    float decay;$/;"	m	struct:network
+deinter_cpu	blas.c	/^void deinter_cpu(int NX, float *X, int NY, float *Y, int B, float *OUT)$/;"	f
+del_arg	utils.c	/^void del_arg(int argc, char **argv, int index)$/;"	f
+delta	include/darknet.h	/^    float * delta;$/;"	m	struct:layer
+delta	include/darknet.h	/^    float *delta;$/;"	m	struct:network
+delta_gpu	include/darknet.h	/^    float * delta_gpu;$/;"	m	struct:layer
+delta_gpu	include/darknet.h	/^    float *delta_gpu;$/;"	m	struct:network
+detection	include/darknet.h	/^typedef struct detection{$/;"	s
+detection	include/darknet.h	/^} detection;$/;"	t	typeref:struct:detection
+dh_cpu	include/darknet.h	/^    float *dh_cpu;$/;"	m	struct:layer
+dh_gpu	include/darknet.h	/^    float *dh_gpu;$/;"	m	struct:layer
+dist_array	utils.c	/^float dist_array(float *a, float *b, int n, int sub)$/;"	f
+distribute_weights	network.c	/^void distribute_weights(layer l, layer base)$/;"	f
+dontload	include/darknet.h	/^    int dontload;$/;"	m	struct:layer
+dontloadscales	include/darknet.h	/^    int dontloadscales;$/;"	m	struct:layer
+dontsave	include/darknet.h	/^    int dontsave;$/;"	m	struct:layer
+dot	include/darknet.h	/^    float dot;$/;"	m	struct:layer
+dot_cpu	blas.c	/^float dot_cpu(int N, float *X, int INCX, float *Y, int INCY)$/;"	f
+dropout_layer	dropout_layer.h	/^typedef layer dropout_layer;$/;"	t
+dsrcTensorDesc	include/darknet.h	/^    cudnnTensorDescriptor_t dsrcTensorDesc, ddstTensorDesc;$/;"	m	struct:layer
+dstTensorDesc	include/darknet.h	/^    cudnnTensorDescriptor_t srcTensorDesc, dstTensorDesc;$/;"	m	struct:layer
+dweightDesc	include/darknet.h	/^    cudnnFilterDescriptor_t dweightDesc;$/;"	m	struct:layer
+dx	include/darknet.h	/^    float dx;$/;"	m	struct:__anon13
+dy	include/darknet.h	/^    float dy;$/;"	m	struct:__anon13
+elu_activate	activations.h	/^static inline float elu_activate(float x){return (x >= 0)*x + (x < 0)*(exp(x)-1);}$/;"	f
+elu_gradient	activations.h	/^static inline float elu_gradient(float x){return (x >= 0) + (x < 0)*(x + 1);}$/;"	f
+epoch	include/darknet.h	/^    float epoch;$/;"	m	struct:network
+eps	include/darknet.h	/^    float eps;$/;"	m	struct:__anon11
+eps	include/darknet.h	/^    float eps;$/;"	m	struct:network
+err	network.c	/^    float *err;$/;"	m	struct:__anon1	file:
+error	utils.c	/^void error(const char *s)$/;"	f
+exposure	include/darknet.h	/^    float exposure;$/;"	m	struct:layer
+exposure	include/darknet.h	/^    float exposure;$/;"	m	struct:load_args
+exposure	include/darknet.h	/^    float exposure;$/;"	m	struct:network
+extra	include/darknet.h	/^    int extra;$/;"	m	struct:layer
+f_cpu	include/darknet.h	/^    float *f_cpu;$/;"	m	struct:layer
+f_gpu	include/darknet.h	/^    float *f_gpu;$/;"	m	struct:layer
+fgetl	utils.c	/^char *fgetl(FILE *fp)$/;"	f
+file_error	utils.c	/^void file_error(char *s)$/;"	f
+fill_cpu	blas.c	/^void fill_cpu(int N, float ALPHA, float *X, int INCX)$/;"	f
+fill_network_boxes	network.c	/^void fill_network_boxes(network *net, int w, int h, float thresh, float hier, int *map, int relative, detection *dets)$/;"	f
+find_arg	utils.c	/^int find_arg(int argc, char* argv[], char *arg)$/;"	f
+find_char_arg	utils.c	/^char *find_char_arg(int argc, char **argv, char *arg, char *def)$/;"	f
+find_float_arg	utils.c	/^float find_float_arg(int argc, char **argv, char *arg, float def)$/;"	f
+find_int_arg	utils.c	/^int find_int_arg(int argc, char **argv, char *arg, int def)$/;"	f
+find_replace	utils.c	/^void find_replace(char *str, char *orig, char *rep, char *output)$/;"	f
+flatten	blas.c	/^void flatten(float *x, int size, int layers, int batch, int forward)$/;"	f
+flatten	include/darknet.h	/^    int flatten;$/;"	m	struct:layer
+flip	include/darknet.h	/^    int flip;$/;"	m	struct:layer
+flipped	include/darknet.h	/^    int flipped;$/;"	m	struct:layer
+focus	include/darknet.h	/^    float focus;$/;"	m	struct:layer
+forced	include/darknet.h	/^    int forced;$/;"	m	struct:layer
+forgot_delta	include/darknet.h	/^    float * forgot_delta;$/;"	m	struct:layer
+forgot_delta_gpu	include/darknet.h	/^    float * forgot_delta_gpu;$/;"	m	struct:layer
+forgot_state	include/darknet.h	/^    float * forgot_state;$/;"	m	struct:layer
+forgot_state_gpu	include/darknet.h	/^    float * forgot_state_gpu;$/;"	m	struct:layer
+forward	include/darknet.h	/^    void (*forward)   (struct layer, struct network);$/;"	m	struct:layer
+forward_activation_layer	activation_layer.c	/^void forward_activation_layer(layer l, network net)$/;"	f
+forward_activation_layer_gpu	activation_layer.c	/^void forward_activation_layer_gpu(layer l, network net)$/;"	f
+forward_add_mask_layer	add_mask_layer.c	/^void forward_add_mask_layer(layer l, network net)$/;"	f
+forward_avgpool_layer	avgpool_layer.c	/^void forward_avgpool_layer(const avgpool_layer l, network net)$/;"	f
+forward_batchnorm_layer	batchnorm_layer.c	/^void forward_batchnorm_layer(layer l, network net)$/;"	f
+forward_batchnorm_layer_gpu	batchnorm_layer.c	/^void forward_batchnorm_layer_gpu(layer l, network net)$/;"	f
+forward_dropout_layer	dropout_layer.c	/^void forward_dropout_layer(dropout_layer l, network net)$/;"	f
+forward_gpu	include/darknet.h	/^    void (*forward_gpu)   (struct layer, struct network);$/;"	m	struct:layer
+forward_linear_transform_layer	linear_transform_layer.c	/^void forward_linear_transform_layer(layer l, network net)$/;"	f
+forward_network	network.c	/^void forward_network(network *netp)$/;"	f
+forward_network_gpu	network.c	/^void forward_network_gpu(network *netp)$/;"	f
+forward_shuffle_channel_layer	shuffle_channel_layer.c	/^void forward_shuffle_channel_layer(layer l, network net)$/;"	f
+forward_softmax_layer	softmax_layer.c	/^void forward_softmax_layer(const softmax_layer l, network net)$/;"	f
+forward_softmax_layer_gpu	softmax_layer.c	/^void forward_softmax_layer_gpu(const softmax_layer l, network net)$/;"	f
+free_detections	network.c	/^void free_detections(detection *dets, int n)$/;"	f
+free_layer	layer.c	/^void free_layer(layer l)$/;"	f
+free_list	list.c	/^void free_list(list *l)$/;"	f
+free_list_contents	list.c	/^void free_list_contents(list *l)$/;"	f
+free_network	network.c	/^void free_network(network *net)$/;"	f
+free_node	list.c	/^void free_node(node *n)$/;"	f
+free_ptrs	utils.c	/^void free_ptrs(void **ptrs, int n)$/;"	f
+free_section	parser.c	/^void free_section(section *s)$/;"	f
+front	include/darknet.h	/^    node *front;$/;"	m	struct:list
+fw_algo	include/darknet.h	/^    cudnnConvolutionFwdAlgo_t fw_algo;$/;"	m	struct:layer
+g_cpu	include/darknet.h	/^    float *g_cpu;$/;"	m	struct:layer
+g_gpu	include/darknet.h	/^    float *g_gpu;$/;"	m	struct:layer
+gamma	include/darknet.h	/^    float gamma;$/;"	m	struct:network
+gate_delta_gpu	include/darknet.h	/^    float * gate_delta_gpu;$/;"	m	struct:layer
+gate_gpu	include/darknet.h	/^    float * gate_gpu;$/;"	m	struct:layer
+get_activation	activations.c	/^ACTIVATION get_activation(char *s)$/;"	f
+get_activation_string	activations.c	/^char *get_activation_string(ACTIVATION a)$/;"	f
+get_base_args	network.c	/^load_args get_base_args(network *net)$/;"	f
+get_current_batch	network.c	/^size_t get_current_batch(network *net)$/;"	f
+get_current_rate	network.c	/^float get_current_rate(network *net)$/;"	f
+get_layer_string	network.c	/^char *get_layer_string(LAYER_TYPE a)$/;"	f
+get_metadata	option_list.c	/^metadata get_metadata(char *file)$/;"	f
+get_network_boxes	network.c	/^detection *get_network_boxes(network *net, int w, int h, float thresh, float hier, int *map, int relative, int *num)$/;"	f
+get_network_detection_layer	network.c	/^layer get_network_detection_layer(network *net)$/;"	f
+get_network_image	network.c	/^image get_network_image(network *net)$/;"	f
+get_network_image_layer	network.c	/^image get_network_image_layer(network *net, int i)$/;"	f
+get_network_output_layer	network.c	/^layer get_network_output_layer(network *net)$/;"	f
+get_policy	parser.c	/^learning_rate_policy get_policy(char *s)$/;"	f
+get_predicted_class_network	network.c	/^int get_predicted_class_network(network *net)$/;"	f
+gpu_index	include/darknet.h	/^    int gpu_index;$/;"	m	struct:network
+gradient	activations.c	/^float gradient(float x, ACTIVATION a)$/;"	f
+gradient_array	activations.c	/^void gradient_array(const float *x, const int n, const ACTIVATION a, float *delta)$/;"	f
+group	include/darknet.h	/^    int *group;$/;"	m	struct:__anon5
+group_offset	include/darknet.h	/^    int *group_offset;$/;"	m	struct:__anon5
+group_size	include/darknet.h	/^    int *group_size;$/;"	m	struct:__anon5
+groups	include/darknet.h	/^    int groups;$/;"	m	struct:__anon5
+groups	include/darknet.h	/^    int groups;$/;"	m	struct:layer
+h	include/darknet.h	/^    float x, y, w, h;$/;"	m	struct:__anon15
+h	include/darknet.h	/^    float x,y,w,h;$/;"	m	struct:__anon18
+h	include/darknet.h	/^    int h, w, c;$/;"	m	struct:network
+h	include/darknet.h	/^    int h,w,c;$/;"	m	struct:layer
+h	include/darknet.h	/^    int h;$/;"	m	struct:__anon13
+h	include/darknet.h	/^    int h;$/;"	m	struct:__anon14
+h	include/darknet.h	/^    int h;$/;"	m	struct:load_args
+h	include/darknet.h	/^    int w, h;$/;"	m	struct:__anon16
+h	parser.c	/^    int h;$/;"	m	struct:size_params	file:
+h_cpu	include/darknet.h	/^    float *h_cpu;$/;"	m	struct:layer
+h_gpu	include/darknet.h	/^    float *h_gpu;$/;"	m	struct:layer
+hardtan_activate	activations.h	/^static inline float hardtan_activate(float x)$/;"	f
+hardtan_gradient	activations.h	/^static inline float hardtan_gradient(float x)$/;"	f
+harmless_update_network_gpu	network.c	/^void harmless_update_network_gpu(network *netp)$/;"	f
+hh_cpu	include/darknet.h	/^    float *hh_cpu;$/;"	m	struct:layer
+hh_gpu	include/darknet.h	/^    float *hh_gpu;$/;"	m	struct:layer
+hidden	include/darknet.h	/^    int hidden;$/;"	m	struct:layer
+hierarchy	include/darknet.h	/^    tree *hierarchy;$/;"	m	struct:load_args
+hierarchy	include/darknet.h	/^    tree *hierarchy;$/;"	m	struct:network
+hue	include/darknet.h	/^    float hue;$/;"	m	struct:load_args
+hue	include/darknet.h	/^    float hue;$/;"	m	struct:network
+i_cpu	include/darknet.h	/^    float *i_cpu;$/;"	m	struct:layer
+i_gpu	include/darknet.h	/^    float *i_gpu;$/;"	m	struct:layer
+id	include/darknet.h	/^    int id;$/;"	m	struct:__anon18
+ignore_thresh	include/darknet.h	/^    float ignore_thresh;$/;"	m	struct:layer
+im	include/darknet.h	/^    image *im;$/;"	m	struct:load_args
+image	include/darknet.h	/^} image;$/;"	t	typeref:struct:__anon14
+index	include/darknet.h	/^    int index;$/;"	m	struct:layer
+index	include/darknet.h	/^    int index;$/;"	m	struct:network
+index	parser.c	/^    int index;$/;"	m	struct:size_params	file:
+indexes	include/darknet.h	/^    int   * indexes;$/;"	m	struct:layer
+indexes_gpu	include/darknet.h	/^    int *indexes_gpu;$/;"	m	struct:layer
+input	include/darknet.h	/^    float *input;$/;"	m	struct:network
+input_gate_layer	include/darknet.h	/^    struct layer *input_gate_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_gpu	include/darknet.h	/^    float *input_gpu;$/;"	m	struct:network
+input_h_layer	include/darknet.h	/^    struct layer *input_h_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_layer	include/darknet.h	/^    struct layer *input_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_layers	include/darknet.h	/^    int   * input_layers;$/;"	m	struct:layer
+input_r_layer	include/darknet.h	/^    struct layer *input_r_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_save_layer	include/darknet.h	/^    struct layer *input_save_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_sizes	include/darknet.h	/^    int   * input_sizes;$/;"	m	struct:layer
+input_state_layer	include/darknet.h	/^    struct layer *input_state_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+input_z_layer	include/darknet.h	/^    struct layer *input_z_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+inputs	include/darknet.h	/^    int inputs;$/;"	m	struct:layer
+inputs	include/darknet.h	/^    int inputs;$/;"	m	struct:network
+inputs	parser.c	/^    int inputs;$/;"	m	struct:size_params	file:
+int_index	utils.c	/^int int_index(int *a, int val, int n)$/;"	f
+int_to_alphanum	utils.c	/^char int_to_alphanum(int i)$/;"	f
+inter_cpu	blas.c	/^void inter_cpu(int NX, float *X, int NY, float *Y, int B, float *OUT)$/;"	f
+is_network	parser.c	/^int is_network(section *s)$/;"	f
+j	network.c	/^    int j;$/;"	m	struct:__anon2	file:
+jitter	include/darknet.h	/^    float jitter;$/;"	m	struct:layer
+jitter	include/darknet.h	/^    float jitter;$/;"	m	struct:load_args
+joint	include/darknet.h	/^    int joint;$/;"	m	struct:layer
+kappa	include/darknet.h	/^    float kappa;$/;"	m	struct:layer
+key	option_list.h	/^    char *key;$/;"	m	struct:__anon19
+kvp	option_list.h	/^} kvp;$/;"	t	typeref:struct:__anon19
+l1_cpu	blas.c	/^void l1_cpu(int n, float *pred, float *truth, float *delta, float *error)$/;"	f
+l2_cpu	blas.c	/^void l2_cpu(int n, float *pred, float *truth, float *delta, float *error)$/;"	f
+l2normalize_cpu	blas.c	/^void l2normalize_cpu(float *x, float *dx, int batch, int filters, int spatial)$/;"	f
+labels	include/darknet.h	/^    char **labels;$/;"	m	struct:load_args
+layer	include/darknet.h	/^struct layer{$/;"	s
+layer	include/darknet.h	/^typedef struct layer layer;$/;"	t	typeref:struct:layer
+layers	include/darknet.h	/^    layer *layers;$/;"	m	struct:network
+leaf	include/darknet.h	/^    int *leaf;$/;"	m	struct:__anon5
+leaky_activate	activations.h	/^static inline float leaky_activate(float x){return (x>0) ? x : .1*x;}$/;"	f
+leaky_gradient	activations.h	/^static inline float leaky_gradient(float x){return (x>0) ? 1 : .1;}$/;"	f
+learning_rate	include/darknet.h	/^    float learning_rate;$/;"	m	struct:__anon11
+learning_rate	include/darknet.h	/^    float learning_rate;$/;"	m	struct:network
+learning_rate_policy	include/darknet.h	/^} learning_rate_policy;$/;"	t	typeref:enum:__anon12
+learning_rate_scale	include/darknet.h	/^    float learning_rate_scale;$/;"	m	struct:layer
+left	include/darknet.h	/^    float left, right, top, bottom;$/;"	m	struct:__anon18
+lhtan_activate	activations.h	/^static inline float lhtan_activate(float x)$/;"	f
+lhtan_gradient	activations.h	/^static inline float lhtan_gradient(float x)$/;"	f
+linear_activate	activations.h	/^static inline float linear_activate(float x){return x;}$/;"	f
+linear_gradient	activations.h	/^static inline float linear_gradient(float x){return 1;}$/;"	f
+list	include/darknet.h	/^typedef struct list{$/;"	s
+list	include/darknet.h	/^} list;$/;"	t	typeref:struct:list
+list_insert	list.c	/^void list_insert(list *l, void *val)$/;"	f
+list_pop	list.c	/^void *list_pop(list *l){$/;"	f
+list_to_array	list.c	/^void **list_to_array(list *l)$/;"	f
+load_add_mask_weights	parser.c	/^void load_add_mask_weights(layer l, FILE *fp)$/;"	f
+load_args	include/darknet.h	/^typedef struct load_args{$/;"	s
+load_args	include/darknet.h	/^} load_args;$/;"	t	typeref:struct:load_args
+load_batchnorm_weights	parser.c	/^void load_batchnorm_weights(layer l, FILE *fp)$/;"	f
+load_connected_weights	parser.c	/^void load_connected_weights(layer l, FILE *fp, int transpose)$/;"	f
+load_convolutional_weights	parser.c	/^void load_convolutional_weights(layer l, FILE *fp)$/;"	f
+load_convolutional_weights_binary	parser.c	/^void load_convolutional_weights_binary(layer l, FILE *fp)$/;"	f
+load_linear_transform_weights	parser.c	/^void load_linear_transform_weights(layer l, FILE *fp)$/;"	f
+load_network	network.c	/^network *load_network(char *cfg, char *weights, int clear)$/;"	f
+load_shuffle_channel_weights	parser.c	/^void load_shuffle_channel_weights(layer l, FILE *fp)$/;"	f
+load_weights	parser.c	/^void load_weights(network *net, char *filename)$/;"	f
+load_weights_upto	parser.c	/^void load_weights_upto(network *net, char *filename, int start, int cutoff)$/;"	f
+log	include/darknet.h	/^    int log;$/;"	m	struct:layer
+loggy_activate	activations.h	/^static inline float loggy_activate(float x){return 2.\/(1. + exp(-x)) - 1;}$/;"	f
+loggy_gradient	activations.h	/^static inline float loggy_gradient(float x)$/;"	f
+logistic_activate	activations.h	/^static inline float logistic_activate(float x){return 1.\/(1. + exp(-x));}$/;"	f
+logistic_gradient	activations.h	/^static inline float logistic_gradient(float x){return (1-x)*x;}$/;"	f
+logistic_x_ent_cpu	blas.c	/^void logistic_x_ent_cpu(int n, float *pred, float *truth, float *delta, float *error)$/;"	f
+loss	include/darknet.h	/^    float * loss;$/;"	m	struct:layer
+loss_gpu	include/darknet.h	/^    float * loss_gpu;$/;"	m	struct:layer
+m	include/darknet.h	/^    float * m;$/;"	m	struct:layer
+m	include/darknet.h	/^    int m;$/;"	m	struct:load_args
+m_gpu	include/darknet.h	/^    float *m_gpu;$/;"	m	struct:layer
+mag_array	utils.c	/^float mag_array(float *a, int n)$/;"	f
+make_activation_layer	activation_layer.c	/^layer make_activation_layer(int batch, int inputs, ACTIVATION activation)$/;"	f
+make_add_mask_layer	add_mask_layer.c	/^layer make_add_mask_layer(int batch, int h, int w, int c)$/;"	f
+make_avgpool_layer	avgpool_layer.c	/^avgpool_layer make_avgpool_layer(int batch, int w, int h, int c)$/;"	f
+make_batchnorm_layer	batchnorm_layer.c	/^layer make_batchnorm_layer(int batch, int w, int h, int c)$/;"	f
+make_dropout_layer	dropout_layer.c	/^dropout_layer make_dropout_layer(int batch, int inputs, float probability)$/;"	f
+make_linear_transform_layer	linear_transform_layer.c	/^layer make_linear_transform_layer(int batch, int h, int w, int c, int units)$/;"	f
+make_list	list.c	/^list *make_list()$/;"	f
+make_network	network.c	/^network *make_network(int n)$/;"	f
+make_network_boxes	network.c	/^detection *make_network_boxes(network *net, float thresh, int *num)$/;"	f
+make_shuffle_channel_layer	shuffle_channel_layer.c	/^layer make_shuffle_channel_layer(int batch, int h, int w, int c)$/;"	f
+make_softmax_layer	softmax_layer.c	/^softmax_layer make_softmax_layer(int batch, int inputs, int groups)$/;"	f
+malloc_error	utils.c	/^void malloc_error()$/;"	f
+map	include/darknet.h	/^    int   * map;$/;"	m	struct:layer
+mask	include/darknet.h	/^    float *mask;$/;"	m	struct:detection
+mask	include/darknet.h	/^    int *mask;$/;"	m	struct:layer
+mask_scale	include/darknet.h	/^    float mask_scale;$/;"	m	struct:layer
+matrix	include/darknet.h	/^typedef struct matrix{$/;"	s
+matrix	include/darknet.h	/^} matrix;$/;"	t	typeref:struct:matrix
+max	include/darknet.h	/^    int min, max, size;$/;"	m	struct:load_args
+max_batches	include/darknet.h	/^    int max_batches;$/;"	m	struct:network
+max_boxes	include/darknet.h	/^    int max_boxes;$/;"	m	struct:layer
+max_crop	include/darknet.h	/^    int max_crop;$/;"	m	struct:network
+max_index	utils.c	/^int max_index(float *a, int n)$/;"	f
+max_int_index	utils.c	/^int max_int_index(int *a, int n)$/;"	f
+max_ratio	include/darknet.h	/^    float max_ratio;$/;"	m	struct:network
+mean	include/darknet.h	/^    float * mean;$/;"	m	struct:layer
+mean_array	utils.c	/^float mean_array(float *a, int n)$/;"	f
+mean_arrays	utils.c	/^void mean_arrays(float **a, int n, int els, float *avg)$/;"	f
+mean_cpu	blas.c	/^void mean_cpu(float *x, int batch, int filters, int spatial, float *mean)$/;"	f
+mean_delta	include/darknet.h	/^    float * mean_delta;$/;"	m	struct:layer
+mean_delta_cpu	batchnorm_layer.c	/^void mean_delta_cpu(float *delta, float *variance, int batch, int filters, int spatial, float *mean_delta)$/;"	f
+mean_delta_gpu	include/darknet.h	/^    float * mean_delta_gpu;$/;"	m	struct:layer
+mean_gpu	include/darknet.h	/^    float * mean_gpu;$/;"	m	struct:layer
+merge_weights	network.c	/^void merge_weights(layer l, layer base)$/;"	f
+metadata	include/darknet.h	/^} metadata;$/;"	t	typeref:struct:__anon4
+min	include/darknet.h	/^    int min, max, size;$/;"	m	struct:load_args
+min_crop	include/darknet.h	/^    int min_crop;$/;"	m	struct:network
+min_ratio	include/darknet.h	/^    float min_ratio;$/;"	m	struct:network
+momentum	include/darknet.h	/^    float momentum;$/;"	m	struct:__anon11
+momentum	include/darknet.h	/^    float momentum;$/;"	m	struct:network
+mse_array	utils.c	/^float mse_array(float *a, int n)$/;"	f
+mul_cpu	blas.c	/^void mul_cpu(int N, float *X, int INCX, float *Y, int INCY)$/;"	f
+mult_add_into_cpu	blas.c	/^void mult_add_into_cpu(int N, float *X, float *Y, float *Z)$/;"	f
+n	include/darknet.h	/^    int n;$/;"	m	struct:__anon5
+n	include/darknet.h	/^    int n;$/;"	m	struct:layer
+n	include/darknet.h	/^    int n;$/;"	m	struct:load_args
+n	include/darknet.h	/^    int n;$/;"	m	struct:network
+n	network.c	/^    int n;$/;"	m	struct:__anon2	file:
+name	include/darknet.h	/^    char **name;$/;"	m	struct:__anon5
+names	include/darknet.h	/^    char **names;$/;"	m	struct:__anon4
+nbiases	include/darknet.h	/^    int nbiases;$/;"	m	struct:layer
+net	network.c	/^    network *net;$/;"	m	struct:__anon1	file:
+net	parser.c	/^    network *net;$/;"	m	struct:size_params	file:
+nets	network.c	/^    network **nets;$/;"	m	struct:__anon2	file:
+network	include/darknet.h	/^typedef struct network network;$/;"	t	typeref:struct:network
+network	include/darknet.h	/^typedef struct network{$/;"	s
+network	include/darknet.h	/^} network;$/;"	t	typeref:struct:network
+network_accuracies	network.c	/^float *network_accuracies(network *net, data d, int n)$/;"	f
+network_accuracy	network.c	/^float network_accuracy(network *net, data d)$/;"	f
+network_accuracy_multi	network.c	/^float network_accuracy_multi(network *net, data d, int n)$/;"	f
+network_height	network.c	/^int network_height(network *net){return net->h;}$/;"	f
+network_inputs	network.c	/^int network_inputs(network *net)$/;"	f
+network_output	network.c	/^float *network_output(network *net)$/;"	f
+network_output_layer	network.c	/^layer network_output_layer(network *net)$/;"	f
+network_outputs	network.c	/^int network_outputs(network *net)$/;"	f
+network_predict	network.c	/^float *network_predict(network *net, float *input)$/;"	f
+network_predict_data	network.c	/^matrix network_predict_data(network *net, data test)$/;"	f
+network_predict_data_multi	network.c	/^matrix network_predict_data_multi(network *net, data test, int n)$/;"	f
+network_predict_image	network.c	/^float *network_predict_image(network *net, image im)$/;"	f
+network_width	network.c	/^int network_width(network *net){return net->w;}$/;"	f
+next	include/darknet.h	/^    struct node *next;$/;"	m	struct:node	typeref:struct:node::node
+nh	include/darknet.h	/^    int nh;$/;"	m	struct:load_args
+nhwc	include/darknet.h	/^    int nhwc;$/;"	m	struct:layer
+noact_activate	activations.h	/^static inline float noact_activate(float x){return x;}$/;"	f
+noact_gradient	activations.h	/^static inline float noact_gradient(float x){return 1;}$/;"	f
+noadjust	include/darknet.h	/^    int noadjust;$/;"	m	struct:layer
+node	include/darknet.h	/^typedef struct node{$/;"	s
+node	include/darknet.h	/^} node;$/;"	t	typeref:struct:node
+noloss	include/darknet.h	/^    int noloss;$/;"	m	struct:layer
+noobject_scale	include/darknet.h	/^    float noobject_scale;$/;"	m	struct:layer
+normTensorDesc	include/darknet.h	/^    cudnnTensorDescriptor_t normTensorDesc;$/;"	m	struct:layer
+normalize_array	utils.c	/^void normalize_array(float *a, int n)$/;"	f
+normalize_cpu	blas.c	/^void normalize_cpu(float *x, float *mean, float *variance, int batch, int filters, int spatial)$/;"	f
+normalize_cpu_nhwc	blas.c	/^void normalize_cpu_nhwc(float *x, float *mean, float *variance, int batch, int filters, int spatial)$/;"	f
+normalize_delta_cpu	batchnorm_layer.c	/^void normalize_delta_cpu(float *x, float *mean, float *variance, float *mean_delta, float *variance_delta, int batch, int filters, int spatial, float *delta)$/;"	f
+norms	include/darknet.h	/^    float * norms;$/;"	m	struct:layer
+norms_gpu	include/darknet.h	/^    float * norms_gpu;$/;"	m	struct:layer
+notruth	include/darknet.h	/^    int notruth;$/;"	m	struct:network
+num_boxes	include/darknet.h	/^    int *num_boxes;$/;"	m	struct:__anon16
+num_boxes	include/darknet.h	/^    int num_boxes;$/;"	m	struct:load_args
+num_detections	network.c	/^int num_detections(network *net, float thresh)$/;"	f
+num_steps	include/darknet.h	/^    int num_steps;$/;"	m	struct:network
+numload	include/darknet.h	/^    int numload;$/;"	m	struct:layer
+nw	include/darknet.h	/^    int nw;$/;"	m	struct:load_args
+nweights	include/darknet.h	/^    int nweights;$/;"	m	struct:layer
+o_cpu	include/darknet.h	/^    float *o_cpu;$/;"	m	struct:layer
+o_gpu	include/darknet.h	/^    float *o_gpu;$/;"	m	struct:layer
+obfweights	include/darknet.h	/^    int *obfweights;$/;"	m	struct:layer
+object_scale	include/darknet.h	/^    float object_scale;$/;"	m	struct:layer
+objectness	include/darknet.h	/^    float objectness;$/;"	m	struct:detection
+objectness	include/darknet.h	/^    int objectness;$/;"	m	struct:layer
+one_hot_encode	utils.c	/^float **one_hot_encode(float *a, int n, int k)$/;"	f
+onlyforward	include/darknet.h	/^    int onlyforward;$/;"	m	struct:layer
+option_find	option_list.c	/^char *option_find(list *l, char *key)$/;"	f
+option_find_float	option_list.c	/^float option_find_float(list *l, char *key, float def)$/;"	f
+option_find_float_quiet	option_list.c	/^float option_find_float_quiet(list *l, char *key, float def)$/;"	f
+option_find_int	option_list.c	/^int option_find_int(list *l, char *key, int def)$/;"	f
+option_find_int_quiet	option_list.c	/^int option_find_int_quiet(list *l, char *key, int def)$/;"	f
+option_find_str	option_list.c	/^char *option_find_str(list *l, char *key, char *def)$/;"	f
+option_insert	option_list.c	/^void option_insert(list *l, char *key, char *val)$/;"	f
+option_unused	option_list.c	/^void option_unused(list *l)$/;"	f
+options	parser.c	/^    list *options;$/;"	m	struct:__anon3	file:
+out_c	include/darknet.h	/^    int out_h, out_w, out_c;$/;"	m	struct:layer
+out_h	include/darknet.h	/^    int out_h, out_w, out_c;$/;"	m	struct:layer
+out_h	include/darknet.h	/^    int out_h;$/;"	m	struct:load_args
+out_w	include/darknet.h	/^    int out_h, out_w, out_c;$/;"	m	struct:layer
+out_w	include/darknet.h	/^    int out_w;$/;"	m	struct:load_args
+output	include/darknet.h	/^    float * output;$/;"	m	struct:layer
+output	include/darknet.h	/^    float *output;$/;"	m	struct:network
+output_gpu	include/darknet.h	/^    float * output_gpu;$/;"	m	struct:layer
+output_gpu	include/darknet.h	/^    float *output_gpu;$/;"	m	struct:network
+output_layer	include/darknet.h	/^    struct layer *output_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+outputs	include/darknet.h	/^    int outputs;$/;"	m	struct:layer
+outputs	include/darknet.h	/^    int outputs;$/;"	m	struct:network
+pad	include/darknet.h	/^    int pad;$/;"	m	struct:layer
+parent	include/darknet.h	/^    int *parent;$/;"	m	struct:__anon5
+parse_activation	parser.c	/^layer parse_activation(list *options, size_params params)$/;"	f
+parse_add_mask	parser.c	/^layer parse_add_mask(list *options, size_params params)$/;"	f
+parse_avgpool	parser.c	/^avgpool_layer parse_avgpool(list *options, size_params params)$/;"	f
+parse_batchnorm	parser.c	/^layer parse_batchnorm(list *options, size_params params)$/;"	f
+parse_connected	parser.c	/^layer parse_connected(list *options, size_params params)$/;"	f
+parse_convolutional	parser.c	/^convolutional_layer parse_convolutional(list *options, size_params params)$/;"	f
+parse_cost	parser.c	/^cost_layer parse_cost(list *options, size_params params)$/;"	f
+parse_crnn	parser.c	/^layer parse_crnn(list *options, size_params params)$/;"	f
+parse_crop	parser.c	/^crop_layer parse_crop(list *options, size_params params)$/;"	f
+parse_csv_line	utils.c	/^list *parse_csv_line(char *line)$/;"	f
+parse_data	parser.c	/^void parse_data(char *data, float *a, int n)$/;"	f
+parse_deconvolutional	parser.c	/^layer parse_deconvolutional(list *options, size_params params)$/;"	f
+parse_detection	parser.c	/^detection_layer parse_detection(list *options, size_params params)$/;"	f
+parse_dropout	parser.c	/^dropout_layer parse_dropout(list *options, size_params params)$/;"	f
+parse_fields	utils.c	/^float *parse_fields(char *line, int n)$/;"	f
+parse_gru	parser.c	/^layer parse_gru(list *options, size_params params)$/;"	f
+parse_iseg	parser.c	/^layer parse_iseg(list *options, size_params params)$/;"	f
+parse_l2norm	parser.c	/^layer parse_l2norm(list *options, size_params params)$/;"	f
+parse_linear_transform	parser.c	/^layer parse_linear_transform(list *options, size_params params)$/;"	f
+parse_local	parser.c	/^local_layer parse_local(list *options, size_params params)$/;"	f
+parse_logistic	parser.c	/^layer parse_logistic(list *options, size_params params)$/;"	f
+parse_lstm	parser.c	/^layer parse_lstm(list *options, size_params params)$/;"	f
+parse_maxpool	parser.c	/^maxpool_layer parse_maxpool(list *options, size_params params)$/;"	f
+parse_net_options	parser.c	/^void parse_net_options(list *options, network *net)$/;"	f
+parse_network_cfg	parser.c	/^network *parse_network_cfg(char *filename)$/;"	f
+parse_normalization	parser.c	/^layer parse_normalization(list *options, size_params params)$/;"	f
+parse_region	parser.c	/^layer parse_region(list *options, size_params params)$/;"	f
+parse_reorg	parser.c	/^layer parse_reorg(list *options, size_params params)$/;"	f
+parse_rnn	parser.c	/^layer parse_rnn(list *options, size_params params)$/;"	f
+parse_route	parser.c	/^route_layer parse_route(list *options, size_params params, network *net)$/;"	f
+parse_shortcut	parser.c	/^layer parse_shortcut(list *options, size_params params, network *net)$/;"	f
+parse_shuffle_channel	parser.c	/^layer parse_shuffle_channel(list *options, size_params params)$/;"	f
+parse_softmax	parser.c	/^layer parse_softmax(list *options, size_params params)$/;"	f
+parse_upsample	parser.c	/^layer parse_upsample(list *options, size_params params, network *net)$/;"	f
+parse_yolo	parser.c	/^layer parse_yolo(list *options, size_params params)$/;"	f
+parse_yolo_mask	parser.c	/^int *parse_yolo_mask(char *a, int *num)$/;"	f
+path	include/darknet.h	/^    char *path;$/;"	m	struct:load_args
+paths	include/darknet.h	/^    char **paths;$/;"	m	struct:load_args
+plse_activate	activations.h	/^static inline float plse_activate(float x)$/;"	f
+plse_gradient	activations.h	/^static inline float plse_gradient(float x){return (x < 0 || x > 1) ? .01 : .125;}$/;"	f
+pm	utils.c	/^void pm(int M, int N, float *A)$/;"	f
+policy	include/darknet.h	/^    learning_rate_policy policy;$/;"	m	struct:network
+pow_cpu	blas.c	/^void pow_cpu(int N, float ALPHA, float *X, int INCX, float *Y, int INCY)$/;"	f
+power	include/darknet.h	/^    float power;$/;"	m	struct:network
+prev	include/darknet.h	/^    struct node *prev;$/;"	m	struct:node	typeref:struct:node::node
+prev_cell_cpu	include/darknet.h	/^    float *prev_cell_cpu;$/;"	m	struct:layer
+prev_cell_gpu	include/darknet.h	/^    float *prev_cell_gpu;$/;"	m	struct:layer
+prev_state	include/darknet.h	/^    float * prev_state;$/;"	m	struct:layer
+prev_state_cpu	include/darknet.h	/^    float * prev_state_cpu;$/;"	m	struct:layer
+prev_state_gpu	include/darknet.h	/^    float * prev_state_gpu;$/;"	m	struct:layer
+print_network	network.c	/^void print_network(network *net)$/;"	f
+print_statistics	utils.c	/^void print_statistics(float *a, int n)$/;"	f
+prob	include/darknet.h	/^    float *prob;$/;"	m	struct:detection
+probability	include/darknet.h	/^    float probability;$/;"	m	struct:layer
+pull_batchnorm_layer	batchnorm_layer.c	/^void pull_batchnorm_layer(layer l)$/;"	f
+pull_network_output	network.c	/^void pull_network_output(network *net)$/;"	f
+pull_softmax_layer_output	softmax_layer.c	/^void pull_softmax_layer_output(const softmax_layer layer)$/;"	f
+pull_weights	network.c	/^void pull_weights(layer l)$/;"	f
+push_batchnorm_layer	batchnorm_layer.c	/^void push_batchnorm_layer(layer l)$/;"	f
+push_weights	network.c	/^void push_weights(layer l)$/;"	f
+r_cpu	include/darknet.h	/^    float *r_cpu;$/;"	m	struct:layer
+r_gpu	include/darknet.h	/^    float *r_gpu;$/;"	m	struct:layer
+rad	include/darknet.h	/^    float rad;$/;"	m	struct:__anon13
+ramp_activate	activations.h	/^static inline float ramp_activate(float x){return x*(x>0)+.1*x;}$/;"	f
+ramp_gradient	activations.h	/^static inline float ramp_gradient(float x){return (x>0)+.1;}$/;"	f
+rand	include/darknet.h	/^    float * rand;$/;"	m	struct:layer
+rand_gpu	include/darknet.h	/^    float * rand_gpu;$/;"	m	struct:layer
+rand_int	utils.c	/^int rand_int(int min, int max)$/;"	f
+rand_normal	utils.c	/^float rand_normal()$/;"	f
+rand_scale	utils.c	/^float rand_scale(float s)$/;"	f
+rand_size_t	utils.c	/^size_t rand_size_t()$/;"	f
+rand_uniform	utils.c	/^float rand_uniform(float min, float max)$/;"	f
+random	include/darknet.h	/^    int random;$/;"	m	struct:layer
+random	include/darknet.h	/^    int random;$/;"	m	struct:network
+random_index_order	utils.c	/^int *random_index_order(int min, int max)$/;"	f
+ratio	include/darknet.h	/^    float ratio;$/;"	m	struct:layer
+rbias	include/darknet.h	/^    float *rbias;$/;"	m	struct:layer
+read_all	utils.c	/^void read_all(int fd, char *buffer, size_t bytes)$/;"	f
+read_all_fail	utils.c	/^int read_all_fail(int fd, char *buffer, size_t bytes)$/;"	f
+read_cfg	parser.c	/^list *read_cfg(char *filename)$/;"	f
+read_data_cfg	option_list.c	/^list *read_data_cfg(char *filename)$/;"	f
+read_file	utils.c	/^unsigned char *read_file(char *filename)$/;"	f
+read_int	utils.c	/^int read_int(int fd)$/;"	f
+read_intlist	utils.c	/^int *read_intlist(char *gpu_list, int *ngpus, int d)$/;"	f
+read_map	utils.c	/^int *read_map(char *filename)$/;"	f
+read_option	option_list.c	/^int read_option(char *s, list *options)$/;"	f
+relie_activate	activations.h	/^static inline float relie_activate(float x){return (x>0) ? x : .01*x;}$/;"	f
+relie_gradient	activations.h	/^static inline float relie_gradient(float x){return (x>0) ? 1 : .01;}$/;"	f
+relu6_activate	activations.h	/^static inline float relu6_activate(float x){return (x < 0.) ? 0 : (6.0 < x) ? 6.0: x;}$/;"	f
+relu6_gradient	activations.h	/^static inline float relu6_gradient(float x){return ((x>0) && (x<6));}$/;"	f
+relu_activate	activations.h	/^static inline float relu_activate(float x){return x*(x>0);}$/;"	f
+relu_gradient	activations.h	/^static inline float relu_gradient(float x){return (x>0);}$/;"	f
+reorg	include/darknet.h	/^    int reorg;$/;"	m	struct:layer
+reorg_cpu	blas.c	/^void reorg_cpu(float *x, int w, int h, int c, int batch, int stride, int forward, float *out)$/;"	f
+rescore	include/darknet.h	/^    int rescore;$/;"	m	struct:layer
+reset_layer	include/darknet.h	/^    struct layer *reset_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+reset_network_state	network.c	/^void reset_network_state(network *net, int b)$/;"	f
+reset_rnn	network.c	/^void reset_rnn(network *net)$/;"	f
+resize_avgpool_layer	avgpool_layer.c	/^void resize_avgpool_layer(avgpool_layer *l, int w, int h)$/;"	f
+resize_batchnorm_layer	batchnorm_layer.c	/^void resize_batchnorm_layer(layer *layer, int w, int h)$/;"	f
+resize_dropout_layer	dropout_layer.c	/^void resize_dropout_layer(dropout_layer *l, int inputs)$/;"	f
+resize_network	network.c	/^int resize_network(network *net, int w, int h)$/;"	f
+resized	include/darknet.h	/^    image *resized;$/;"	m	struct:load_args
+reverse	include/darknet.h	/^    int reverse;$/;"	m	struct:layer
+right	include/darknet.h	/^    float left, right, top, bottom;$/;"	m	struct:__anon18
+rolling_mean	include/darknet.h	/^    float * rolling_mean;$/;"	m	struct:layer
+rolling_mean_gpu	include/darknet.h	/^    float * rolling_mean_gpu;$/;"	m	struct:layer
+rolling_variance	include/darknet.h	/^    float * rolling_variance;$/;"	m	struct:layer
+rolling_variance_gpu	include/darknet.h	/^    float * rolling_variance_gpu;$/;"	m	struct:layer
+rows	include/darknet.h	/^    int rows, cols;$/;"	m	struct:matrix
+rscalar	include/darknet.h	/^    float *rscalar;$/;"	m	struct:layer
+sample_array	utils.c	/^int sample_array(float *a, int n)$/;"	f
+saturation	include/darknet.h	/^    float saturation;$/;"	m	struct:layer
+saturation	include/darknet.h	/^    float saturation;$/;"	m	struct:load_args
+saturation	include/darknet.h	/^    float saturation;$/;"	m	struct:network
+save_add_mask_weights	parser.c	/^void save_add_mask_weights(layer l, FILE *fp)$/;"	f
+save_batchnorm_weights	parser.c	/^void save_batchnorm_weights(layer l, FILE *fp)$/;"	f
+save_connected_weights	parser.c	/^void save_connected_weights(layer l, FILE *fp)$/;"	f
+save_convolutional_weights	parser.c	/^void save_convolutional_weights(layer l, FILE *fp)$/;"	f
+save_convolutional_weights_binary	parser.c	/^void save_convolutional_weights_binary(layer l, FILE *fp)$/;"	f
+save_delta_gpu	include/darknet.h	/^    float * save_delta_gpu;$/;"	m	struct:layer
+save_gpu	include/darknet.h	/^    float * save_gpu;$/;"	m	struct:layer
+save_linear_transform_weights	parser.c	/^void save_linear_transform_weights(layer l, FILE *fp)$/;"	f
+save_shuffle_channel_weights	parser.c	/^void save_shuffle_channel_weights(layer l, FILE *fp)$/;"	f
+save_weights	parser.c	/^void save_weights(network *net, char *filename)$/;"	f
+save_weights_upto	parser.c	/^void save_weights_upto(network *net, char *filename, int cutoff)$/;"	f
+scal_cpu	blas.c	/^void scal_cpu(int N, float ALPHA, float *X, int INCX)$/;"	f
+scale	include/darknet.h	/^    float scale;$/;"	m	struct:__anon13
+scale	include/darknet.h	/^    float scale;$/;"	m	struct:layer
+scale	include/darknet.h	/^    float scale;$/;"	m	struct:network
+scale	include/darknet.h	/^    int scale;$/;"	m	struct:load_args
+scale_array	utils.c	/^void scale_array(float *a, int n, float s)$/;"	f
+scale_change_gpu	include/darknet.h	/^    float * scale_change_gpu;$/;"	m	struct:layer
+scale_m	include/darknet.h	/^    float * scale_m;$/;"	m	struct:layer
+scale_m_gpu	include/darknet.h	/^    float *scale_m_gpu;$/;"	m	struct:layer
+scale_updates	include/darknet.h	/^    float * scale_updates;$/;"	m	struct:layer
+scale_updates_gpu	include/darknet.h	/^    float * scale_updates_gpu;$/;"	m	struct:layer
+scale_v	include/darknet.h	/^    float * scale_v;$/;"	m	struct:layer
+scale_v_gpu	include/darknet.h	/^    float *scale_v_gpu;$/;"	m	struct:layer
+scale_weights	network.c	/^void scale_weights(layer l, float s)$/;"	f
+scales	include/darknet.h	/^    float * scales;$/;"	m	struct:layer
+scales	include/darknet.h	/^    float *scales;$/;"	m	struct:network
+scales_gpu	include/darknet.h	/^    float * scales_gpu;$/;"	m	struct:layer
+sec	utils.c	/^float sec(clock_t clocks)$/;"	f
+section	parser.c	/^}section;$/;"	t	typeref:struct:__anon3	file:
+seen	include/darknet.h	/^    size_t *seen;$/;"	m	struct:network
+self_layer	include/darknet.h	/^    struct layer *self_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+selu_activate	activations.h	/^static inline float selu_activate(float x){return (x >= 0)*1.0507*x + (x < 0)*1.0507*1.6732*(exp(x)-1);}$/;"	f
+selu_gradient	activations.h	/^static inline float selu_gradient(float x){return (x >= 0)*1.0507 + (x < 0)*(x + 1.0507*1.6732);}$/;"	f
+set_batch_network	network.c	/^void set_batch_network(network *net, int b)$/;"	f
+set_temp_network	network.c	/^void set_temp_network(network *net, float t)$/;"	f
+shallow	include/darknet.h	/^    int shallow;$/;"	m	struct:__anon16
+shift	include/darknet.h	/^    float shift;$/;"	m	struct:layer
+shortcut	include/darknet.h	/^    int shortcut;$/;"	m	struct:layer
+shortcut_cpu	blas.c	/^void shortcut_cpu(int batch, int w1, int h1, int c1, float *add, int w2, int h2, int c2, float s1, float s2, float *out)$/;"	f
+shuffle	utils.c	/^void shuffle(void *arr, size_t n, size_t size)$/;"	f
+side	include/darknet.h	/^    int side;$/;"	m	struct:layer
+size	include/darknet.h	/^    int min, max, size;$/;"	m	struct:load_args
+size	include/darknet.h	/^    int size;$/;"	m	struct:layer
+size	include/darknet.h	/^    int size;$/;"	m	struct:list
+size_params	parser.c	/^typedef struct size_params{$/;"	s	file:
+size_params	parser.c	/^} size_params;$/;"	t	typeref:struct:size_params	file:
+smooth	include/darknet.h	/^    float smooth;$/;"	m	struct:layer
+smooth_l1_cpu	blas.c	/^void smooth_l1_cpu(int n, float *pred, float *truth, float *delta, float *error)$/;"	f
+softmax	blas.c	/^void softmax(float *input, int n, float temp, int stride, float *output)$/;"	f
+softmax	include/darknet.h	/^    int softmax;$/;"	m	struct:layer
+softmax_cpu	blas.c	/^void softmax_cpu(float *input, int n, int batch, int batch_offset, int groups, int group_offset, int stride, float temp, float *output)$/;"	f
+softmax_layer	softmax_layer.h	/^typedef layer softmax_layer;$/;"	t
+softmax_tree	include/darknet.h	/^    tree *softmax_tree;$/;"	m	struct:layer
+softmax_x_ent_cpu	blas.c	/^void softmax_x_ent_cpu(int n, float *pred, float *truth, float *delta, float *error)$/;"	f
+sort_class	include/darknet.h	/^    int sort_class;$/;"	m	struct:detection
+sorta_shuffle	utils.c	/^void sorta_shuffle(void *arr, size_t n, size_t size, size_t sections)$/;"	f
+spatial	include/darknet.h	/^    int spatial;$/;"	m	struct:layer
+spatial_mean	include/darknet.h	/^    float * spatial_mean;$/;"	m	struct:layer
+split_str	utils.c	/^list *split_str(char *s, char delim)$/;"	f
+sqrt	include/darknet.h	/^    int sqrt;$/;"	m	struct:layer
+squared	include/darknet.h	/^    float * squared;$/;"	m	struct:layer
+squared_gpu	include/darknet.h	/^    float * squared_gpu;$/;"	m	struct:layer
+srcTensorDesc	include/darknet.h	/^    cudnnTensorDescriptor_t srcTensorDesc, dstTensorDesc;$/;"	m	struct:layer
+stair_activate	activations.h	/^static inline float stair_activate(float x)$/;"	f
+stair_gradient	activations.h	/^static inline float stair_gradient(float x)$/;"	f
+state	include/darknet.h	/^    float * state;$/;"	m	struct:layer
+state_delta	include/darknet.h	/^    float * state_delta;$/;"	m	struct:layer
+state_delta_gpu	include/darknet.h	/^    float * state_delta_gpu;$/;"	m	struct:layer
+state_gate_layer	include/darknet.h	/^    struct layer *state_gate_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_gpu	include/darknet.h	/^    float * state_gpu;$/;"	m	struct:layer
+state_h_layer	include/darknet.h	/^    struct layer *state_h_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_layer	include/darknet.h	/^    struct layer *state_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_r_layer	include/darknet.h	/^    struct layer *state_r_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_save_layer	include/darknet.h	/^    struct layer *state_save_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_state_layer	include/darknet.h	/^    struct layer *state_state_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+state_z_layer	include/darknet.h	/^    struct layer *state_z_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+step	include/darknet.h	/^    int step;$/;"	m	struct:network
+steps	include/darknet.h	/^    int   *steps;$/;"	m	struct:network
+steps	include/darknet.h	/^    int steps;$/;"	m	struct:layer
+stopbackward	include/darknet.h	/^    int stopbackward;$/;"	m	struct:layer
+stride	include/darknet.h	/^    int stride;$/;"	m	struct:layer
+string_to_layer_type	parser.c	/^LAYER_TYPE string_to_layer_type(char * type)$/;"	f
+strip	utils.c	/^void strip(char *s)$/;"	f
+strip_char	utils.c	/^void strip_char(char *s, char bad)$/;"	f
+subdivisions	include/darknet.h	/^    int subdivisions;$/;"	m	struct:network
+sum_array	utils.c	/^float sum_array(float *a, int n)$/;"	f
+sums	include/darknet.h	/^    float ** sums;$/;"	m	struct:layer
+sync_args	network.c	/^} sync_args;$/;"	t	typeref:struct:__anon2	file:
+sync_layer	network.c	/^void sync_layer(network **nets, int n, int j)$/;"	f
+sync_layer_in_thread	network.c	/^pthread_t sync_layer_in_thread(network **nets, int n, int j)$/;"	f
+sync_layer_thread	network.c	/^void *sync_layer_thread(void *ptr)$/;"	f
+sync_nets	network.c	/^void sync_nets(network **nets, int n, int interval)$/;"	f
+t	include/darknet.h	/^    int *t;$/;"	m	struct:network
+t	include/darknet.h	/^    int t;$/;"	m	struct:__anon11
+tanh	include/darknet.h	/^    int tanh;$/;"	m	struct:layer
+tanh_activate	activations.h	/^static inline float tanh_activate(float x){return (exp(2*x)-1)\/(exp(2*x)+1);}$/;"	f
+tanh_gradient	activations.h	/^static inline float tanh_gradient(float x){return 1-x*x;}$/;"	f
+temp2_cpu	include/darknet.h	/^    float *temp2_cpu;$/;"	m	struct:layer
+temp2_gpu	include/darknet.h	/^    float *temp2_gpu;$/;"	m	struct:layer
+temp3_cpu	include/darknet.h	/^    float *temp3_cpu;$/;"	m	struct:layer
+temp3_gpu	include/darknet.h	/^    float *temp3_gpu;$/;"	m	struct:layer
+temp_cpu	include/darknet.h	/^    float *temp_cpu;$/;"	m	struct:layer
+temp_gpu	include/darknet.h	/^    float *temp_gpu;$/;"	m	struct:layer
+temperature	include/darknet.h	/^    float temperature;$/;"	m	struct:layer
+threads	include/darknet.h	/^    int threads;$/;"	m	struct:load_args
+thresh	include/darknet.h	/^    float thresh;$/;"	m	struct:layer
+time_steps	include/darknet.h	/^    int time_steps;$/;"	m	struct:network
+time_steps	parser.c	/^    int time_steps;$/;"	m	struct:size_params	file:
+top	include/darknet.h	/^    float left, right, top, bottom;$/;"	m	struct:__anon18
+top_k	utils.c	/^void top_k(float *a, int n, int k, int *index)$/;"	f
+top_predictions	network.c	/^void top_predictions(network *net, int k, int *index)$/;"	f
+total	include/darknet.h	/^    int total;$/;"	m	struct:layer
+train	include/darknet.h	/^    int train;$/;"	m	struct:network
+train_args	network.c	/^} train_args;$/;"	t	typeref:struct:__anon1	file:
+train_network	network.c	/^float train_network(network *net, data d)$/;"	f
+train_network_datum	network.c	/^float train_network_datum(network *net)$/;"	f
+train_network_in_thread	network.c	/^pthread_t train_network_in_thread(network *net, data d, float *err)$/;"	f
+train_network_sgd	network.c	/^float train_network_sgd(network *net, data d, int n)$/;"	f
+train_networks	network.c	/^float train_networks(network **nets, int n, data d, int interval)$/;"	f
+train_thread	network.c	/^void *train_thread(void *ptr)$/;"	f
+translate_array	utils.c	/^void translate_array(float *a, int n, float s)$/;"	f
+transpose_matrix	parser.c	/^void transpose_matrix(float *a, int rows, int cols)$/;"	f
+tree	include/darknet.h	/^} tree;$/;"	t	typeref:struct:__anon5
+truth	include/darknet.h	/^    float *truth;$/;"	m	struct:network
+truth	include/darknet.h	/^    int truth;$/;"	m	struct:layer
+truth_gpu	include/darknet.h	/^    float *truth_gpu;$/;"	m	struct:network
+truth_thresh	include/darknet.h	/^    float truth_thresh;$/;"	m	struct:layer
+truths	include/darknet.h	/^    int truths;$/;"	m	struct:layer
+truths	include/darknet.h	/^    int truths;$/;"	m	struct:network
+type	include/darknet.h	/^    LAYER_TYPE type;$/;"	m	struct:layer
+type	include/darknet.h	/^    data_type type;$/;"	m	struct:load_args
+type	parser.c	/^    char *type;$/;"	m	struct:__anon3	file:
+uf	include/darknet.h	/^    struct layer *uf;$/;"	m	struct:layer	typeref:struct:layer::layer
+ug	include/darknet.h	/^    struct layer *ug;$/;"	m	struct:layer	typeref:struct:layer::layer
+uh	include/darknet.h	/^    struct layer *uh;$/;"	m	struct:layer	typeref:struct:layer::layer
+ui	include/darknet.h	/^    struct layer *ui;$/;"	m	struct:layer	typeref:struct:layer::layer
+units	include/darknet.h	/^    int units;$/;"	m	struct:layer
+uo	include/darknet.h	/^    struct layer *uo;$/;"	m	struct:layer	typeref:struct:layer::layer
+update	include/darknet.h	/^    void (*update)    (struct layer, update_args);$/;"	m	struct:layer
+update_args	include/darknet.h	/^} update_args;$/;"	t	typeref:struct:__anon11
+update_gpu	include/darknet.h	/^    void (*update_gpu)    (struct layer, update_args);$/;"	m	struct:layer
+update_layer	include/darknet.h	/^    struct layer *update_layer;$/;"	m	struct:layer	typeref:struct:layer::layer
+update_network	network.c	/^void update_network(network *netp)$/;"	f
+update_network_gpu	network.c	/^void update_network_gpu(network *netp)$/;"	f
+upsample_cpu	blas.c	/^void upsample_cpu(float *in, int w, int h, int c, int batch, int stride, int forward, float scale, float *out)$/;"	f
+ur	include/darknet.h	/^    struct layer *ur;$/;"	m	struct:layer	typeref:struct:layer::layer
+used	option_list.h	/^    int used;$/;"	m	struct:__anon19
+uz	include/darknet.h	/^    struct layer *uz;$/;"	m	struct:layer	typeref:struct:layer::layer
+v	include/darknet.h	/^    float * v;$/;"	m	struct:layer
+v_gpu	include/darknet.h	/^    float *v_gpu;$/;"	m	struct:layer
+val	include/darknet.h	/^    void *val;$/;"	m	struct:node
+val	option_list.h	/^    char *val;$/;"	m	struct:__anon19
+vals	include/darknet.h	/^    float **vals;$/;"	m	struct:matrix
+variance	include/darknet.h	/^    float * variance;$/;"	m	struct:layer
+variance_array	utils.c	/^float variance_array(float *a, int n)$/;"	f
+variance_cpu	blas.c	/^void variance_cpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)$/;"	f
+variance_delta	include/darknet.h	/^    float * variance_delta;$/;"	m	struct:layer
+variance_delta_cpu	batchnorm_layer.c	/^void  variance_delta_cpu(float *x, float *delta, float *mean, float *variance, int batch, int filters, int spatial, float *variance_delta)$/;"	f
+variance_delta_gpu	include/darknet.h	/^    float * variance_delta_gpu;$/;"	m	struct:layer
+variance_gpu	include/darknet.h	/^    float * variance_gpu;$/;"	m	struct:layer
+visualize_network	network.c	/^void visualize_network(network *net)$/;"	f
+w	include/darknet.h	/^    float x, y, w, h;$/;"	m	struct:__anon15
+w	include/darknet.h	/^    float x,y,w,h;$/;"	m	struct:__anon18
+w	include/darknet.h	/^    int h, w, c;$/;"	m	struct:network
+w	include/darknet.h	/^    int h,w,c;$/;"	m	struct:layer
+w	include/darknet.h	/^    int w, h;$/;"	m	struct:__anon16
+w	include/darknet.h	/^    int w;$/;"	m	struct:__anon13
+w	include/darknet.h	/^    int w;$/;"	m	struct:__anon14
+w	include/darknet.h	/^    int w;$/;"	m	struct:load_args
+w	parser.c	/^    int w;$/;"	m	struct:size_params	file:
+weightDesc	include/darknet.h	/^    cudnnFilterDescriptor_t weightDesc;$/;"	m	struct:layer
+weight_change_gpu	include/darknet.h	/^    float * weight_change_gpu;$/;"	m	struct:layer
+weight_updates	include/darknet.h	/^    float * weight_updates;$/;"	m	struct:layer
+weight_updates_gpu	include/darknet.h	/^    float * weight_updates_gpu;$/;"	m	struct:layer
+weighted_delta_cpu	blas.c	/^void weighted_delta_cpu(float *a, float *b, float *s, float *da, float *db, float *ds, int n, float *dc)$/;"	f
+weighted_sum_cpu	blas.c	/^void weighted_sum_cpu(float *a, float *b, float *s, int n, float *c)$/;"	f
+weights	include/darknet.h	/^    float * weights;$/;"	m	struct:layer
+weights_gpu	include/darknet.h	/^    float * weights_gpu;$/;"	m	struct:layer
+wf	include/darknet.h	/^    struct layer *wf;$/;"	m	struct:layer	typeref:struct:layer::layer
+wg	include/darknet.h	/^    struct layer *wg;$/;"	m	struct:layer	typeref:struct:layer::layer
+wh	include/darknet.h	/^    struct layer *wh;$/;"	m	struct:layer	typeref:struct:layer::layer
+what_time_is_it_now	utils.c	/^double what_time_is_it_now()$/;"	f
+wi	include/darknet.h	/^    struct layer *wi;$/;"	m	struct:layer	typeref:struct:layer::layer
+wo	include/darknet.h	/^    struct layer *wo;$/;"	m	struct:layer	typeref:struct:layer::layer
+workspace	include/darknet.h	/^    float *workspace;$/;"	m	struct:network
+workspace_size	include/darknet.h	/^    size_t workspace_size;$/;"	m	struct:layer
+wr	include/darknet.h	/^    struct layer *wr;$/;"	m	struct:layer	typeref:struct:layer::layer
+write_all	utils.c	/^void write_all(int fd, char *buffer, size_t bytes)$/;"	f
+write_all_fail	utils.c	/^int write_all_fail(int fd, char *buffer, size_t bytes)$/;"	f
+write_int	utils.c	/^void write_int(int fd, int n)$/;"	f
+wz	include/darknet.h	/^    struct layer *wz;$/;"	m	struct:layer	typeref:struct:layer::layer
+x	include/darknet.h	/^    float * x;$/;"	m	struct:layer
+x	include/darknet.h	/^    float x, y, w, h;$/;"	m	struct:__anon15
+x	include/darknet.h	/^    float x,y,w,h;$/;"	m	struct:__anon18
+x_gpu	include/darknet.h	/^    float * x_gpu;$/;"	m	struct:layer
+x_norm	include/darknet.h	/^    float * x_norm;$/;"	m	struct:layer
+x_norm_gpu	include/darknet.h	/^    float * x_norm_gpu;$/;"	m	struct:layer
+xnor	include/darknet.h	/^    int xnor;$/;"	m	struct:layer
+y	include/darknet.h	/^    float x, y, w, h;$/;"	m	struct:__anon15
+y	include/darknet.h	/^    float x,y,w,h;$/;"	m	struct:__anon18
+y	include/darknet.h	/^    matrix y;$/;"	m	struct:__anon16
+z_cpu	include/darknet.h	/^    float *z_cpu;$/;"	m	struct:layer
+z_gpu	include/darknet.h	/^    float *z_gpu;$/;"	m	struct:layer
-- 
2.7.4

